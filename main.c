/*=========================================================================
 *
 *   Filename:           Makefile
 *
 *   Author:             Marcelo Mourier
 *   Created:            Fri Mar 12 09:56:32 PST 2021
 *
 *   Description:        This tool is used to process the activity metrics
 *                       in a GPX or TCX file.
 *
 *=========================================================================
 *
 *                  Copyright (c) 2021 Marcelo Mourier
 *
 *=========================================================================
*/

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/queue.h>
#include <time.h>

#define PROGRAM_VERSION     "0.6"

// Build info auto-generated by make
extern const char *buildInfo;

typedef enum Bool {
    false = 0,
    true = 1
} Bool;

// GPS Track Point
typedef struct TrkPt {
    TAILQ_ENTRY(TrkPt)   tqEntry;   // node in the trkPtList

    int index;          // index in the trkPtList
    int lineNum;        // line number in the input GPX file
    const char *inFile; // input GPX file this trkpt came from

    // GPS data from GPX file
    double latitude;    // in degrees decimal
    double longitude;   // in degrees decimal
    double elevation;   // in meters
    double time;        // in seconds+millisec since the Epoch

    // Sensor data from GPX file
    int ambTemp;        // in degrees Celsius
    int cadence;        // in rpm
    int heartRate;      // in bpm
    int power;          // in watts

    // Computed metrics
    Bool adjGrade;      // grade was adjusted
    double adjTime;     // adjusted timestamp
    double deltaT;      // time diff with previous point (in seconds)
    double deltaP;      // position diff (distance) with previous point (in meters)
    double deltaE;      // elevation diff with previous point (in meters)
    double run;         // horizontal distance from previous point (in meters)
    double distance;    // actual distance from the start (in meters)
    double speed;       // actual speed (in km/h)
    double grade;       // actual grade (in percentage)
} TrkPt;

// GPS Track (sequence of Track Points)
typedef struct GpsTrk {
    // List of TrkPt's
    TAILQ_HEAD(TrkPtList, TrkPt) trkPtList;

    // Number of TrkPt's in trkPtList
    int numTrkPts;

    // Number of TrkPt's that had their elevation values
    // adjusted to match the min/max grade levels.
    int numElevAdj;

    // Number of TrkPt's discarded because they were a
    // duplicate of the previous point
    int numDupTrkPts;

    // Number of TrkPt's trimmed out
    int numTrimTrkPts;

    // Number of optional sensor tags
    int optTagCount;

    int index;
    int trkPtNum;

    // Activity's start/end times
    double startTime;
    double endTime;

    // Base time
    double baseTime;                // time reference to generate relative timestamps

    // Time offset
    double timeOffset;              // to set/change the activity's start time

    // Aggregate values
    double time;
    double stoppedTime;             // amount of time with speed=0
    double distance;
    double elevGain;
    double elevLoss;

    // Min/Max values
    double maxDeltaP;
    double maxDeltaT;
    double maxSpeed;
    double maxGrade;
    double minGrade;

    const TrkPt *maxDeltaPTrkPt;    // TrkPt with max distance
    const TrkPt *maxDeltaTTrkPt;    // TrkPt with max time interval
    const TrkPt *maxSpeedTrkPt;     // TrkPt with max speed value
    const TrkPt *maxGradeTrkPt;     // TrkPt with max grade value
    const TrkPt *minGradeTrkPt;     // TrkPt with min grade value
} GpsTrk;

// Output file format
typedef enum OutFmt {
    nil = 0,
    csv = 1,    // Comma-Separated-Values format
    gpx = 2,    // GPS Exchange format
    tcx = 3     // Training Center Exchange format
} OutFmt;

// Output sensor data bit masks
#define OM_NONE     0x00    // no metrics
#define OM_ATEMP    0x01    // ambient temperature
#define OM_CADENCE  0x02    // cadence
#define OM_HR       0x04    // heart rate
#define OM_POWER    0x08    // power
#define OM_ALL      0x0f    // all metrics

// Timestamp format
typedef enum TsFmt {
    none = 0,
    seconds = 1,        // plain seconds
    hhmmss = 2          // hh:mm:ss
} TsFmt;

typedef struct CmdArgs {
    int argc;           // number of arguments
    char **argv;        // list of arguments
    const char *inFile; // input file

    int closeGap;       // close the time gap at the specified track point
    double maxGrade;    // max grade allowed (in %)
    int maxTimeGap;     // max time gap between points (in sec)
    double minGrade;    // min grade allowed (in %)
    double minSpeed;    // min speed below which we assume we are stopped
    const char *name;   // <name> tag
    FILE *outFile;      // output file
    OutFmt outFmt;      // format of the output data (csv, gpx)
    int outMask;        // bitmask of optional metrics to be included in the output
    Bool quiet;         // don't print any warning messages
    int rangeFrom;      // start point (inclusive)
    int rangeTo;        // end point (inclusive)
    TsFmt relTime;      // show relative timestamps in the specified format
    double setSpeed;    // speed to use to generate timestamps (in m/s)
    int smaWindow;      // size of the moving average window
    double startTime;   // start time for the activity
    Bool summary;       // show data summary
    Bool trim;          // trim points
    Bool verbatim;      // no data adjustments
    int type;           // activity type
} CmdArgs;

static const char *xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
static const char *gpxHeader = "<gpx creator=\"gpxFileTool\" version=\"%s\"\n"
                               "  xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/11.xsd\"\n"
                               "  xmlns:ns3=\"http://www.garmin.com/xmlschemas/TrackPointExtension/v1\"\n"
                               "  xmlns=\"http://www.topografix.com/GPX/1/1\"\n"
                               "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:ns2=\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\">\n";
static const char *tcxHeader = "<TrainingCenterDatabase\n"
                               "  xsi:schemaLocation=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd\"\n"
                               "  xmlns:ns5=\"http://www.garmin.com/xmlschemas/ActivityGoals/v1\"\n"
                               "  xmlns:ns3=\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\"\n"
                               "  xmlns:ns2=\"http://www.garmin.com/xmlschemas/UserProfile/v2\"\n"
                               "  xmlns=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2\"\n"
                               "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:ns4=\"http://www.garmin.com/xmlschemas/ProfileExtension/v1\">\n";

static const double degToRad = (double) 0.01745329252;  // decimal degrees to radians
static const double earthMeanRadius = (double) 6372797.560856;  // in meters

static const char *help =
        "SYNTAX:\n"
        "    gpxFileTool [OPTIONS] <file> [<file2> ...]\n"
        "\n"
        "    When <file> is omitted or it is the string \"-\" input data is read\n"
        "    from standard input.  When multiple input files are specified, the\n"
        "    tool will attempt to stitch them together into a single output file.\n"
        "\n"
        "OPTIONS:\n"
        "    --close-gap <point>\n"
        "        Close the time gap at the specified track point.\n"
        "    --help\n"
        "        Show this help and exit.\n"
        "    --max-grade <value>\n"
        "        Limit the maximum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --max-time-gap <value>\n"
        "        Limit the maximum time gap between points to the specified value.\n"
        "    --min-grade <value>\n"
        "        Limit the minimum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --name <name>\n"
        "        String to use for the <name> tag of the track in the output\n"
        "        GPX file.\n"
        "    --output-file <name>\n"
        "        Write the output data into the specified file. If not specified\n"
        "        the output data is written to standard output.\n"
        "    --output-filter <mask>\n"
        "        A bit mask that specifies the set of optional metrics to be\n"
        "        suppressed from the output:\n"
        "            0x01 - Ambient Temperature\n"
        "            0x02 - Cadence\n"
        "            0x04 - Heart Rate\n"
        "            0x08 - Power\n"
        "    --output-format {csv|gpx|tcx}\n"
        "        Specifies the format of the output data.\n"
        "    --quiet\n"
        "        Suppress all warning messages.\n"
        "    --range <a,b>\n"
        "        Limit the track points to be processed to the range between point\n"
        "        'a' and point 'b', inclusive.\n"
        "    --rel-time <fmt>\n"
        "        Use relative timestamps in the CSV output, using the following\n"
        "        format:\n"
        "            1 - seconds\n"
        "            2 - hh:mm:ss\n"
        "    --remove-stops <speed>\n"
        "        Remove any points with a speed below the specified minimum\n"
        "        speed (in km/s), assuming we were actually stopped at the time.\n"
        "    --set-speed <speed>\n"
        "        Use the specified speed value (in km/h) to generate missing\n"
        "        timestamps in the input GPX file.\n"
        "    --sma-window <value>\n"
        "        Size of the window used to compute the Simple Moving Average\n"
        "        of the elevation values, in order to smooth them out. It must be\n"
        "        an odd value.\n"
        "    --start-time <time>\n"
        "        Start time for the activity (in UTC time). The timestamp of each\n"
        "        point is adjusted accordingly. Format is: 2018-01-22T10:01:10Z.\n"
        "    --summary\n"
        "        Print only a summary of the activity metrics in human-readable\n"
        "        form and exit.\n"
        "    --trim\n"
        "        Trim all the points in the specified range. The timestamps of\n"
        "        the points after point 'b' are adjusted accordingly, to avoid\n"
        "        a discontinuity in the time sequence.\n"
        "    --verbatim\n"
        "        Process the input file(s) verbatim, without making any adjust-\n"
        "        ments to the data.\n"
        "    --version\n"
        "        Show version information and exit.";

static void invalidArgument(const char *arg, const char *val)
{
    invalidArgument(arg, val);
}

static int parseArgs(int argc, char **argv, CmdArgs *pArgs)
{
    int numArgs, n;

    if (argc < 2) {
        fprintf(stderr, "Invalid syntax.  Use 'gpxFileTool --help' for more information.\n");
        return -1;
    }

    // By default include all optional metrics in the output
    pArgs->outMask = OM_ALL;

    for (n = 1, numArgs = argc -1; n <= numArgs; n++) {
        const char *arg;
        const char *val;

        arg = argv[n];

        if (strcmp(arg, "--help") == 0) {
            fprintf(stdout, "%s\n", help);
            exit(0);
        } else if (strcmp(arg, "--close-gap") == 0) {
            val = argv[++n];
            if (sscanf(val, "%d", &pArgs->closeGap) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--max-grade") == 0) {
            val = argv[++n];
            if (sscanf(val, "%le", &pArgs->maxGrade) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--max-time-gap") == 0) {
            val = argv[++n];
            if (sscanf(val, "%d", &pArgs->maxTimeGap) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--min-grade") == 0) {
            val = argv[++n];
            if (sscanf(val, "%le", &pArgs->minGrade) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--name") == 0) {
            val = argv[++n];
            if ((pArgs->name = strdup(val)) == NULL) {
                fprintf(stderr, "Can't copy name argument: %s\n", val);
                return -1;
            }
        } else if (strcmp(arg, "--output-file") == 0) {
            val = argv[++n];
            if ((pArgs->outFile = fopen(val, "w")) == NULL) {
                fprintf(stderr, "Can't open output file %s (%s)\n", val, strerror(errno));
                return -1;
            }
        } else if (strcmp(arg, "--output-filter") == 0) {
            val = argv[++n];
            int mask = 0;
            if (sscanf(val, "0x%x", &mask) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
            pArgs->outMask &= ~mask;
        } else if (strcmp(arg, "--output-format") == 0) {
            val = argv[++n];
            if (strcmp(val, "csv") == 0) {
                pArgs->outFmt = csv;
            } else if (strcmp(val, "gpx") == 0) {
                pArgs->outFmt = gpx;
            } else if (strcmp(val, "tcx") == 0) {
                pArgs->outFmt = tcx;
            } else {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--quiet") == 0) {
            pArgs->quiet = true;
        } else if (strcmp(arg, "--range") == 0) {
            val = argv[++n];
            if (sscanf(val, "%d,%d", &pArgs->rangeFrom, &pArgs->rangeTo) != 2) {
                invalidArgument(arg, val);
                return -1;
            }
            if ((pArgs->rangeFrom < 1) || (pArgs->rangeFrom >= pArgs->rangeTo)) {
                fprintf(stderr, "Invalid TrkPt range %d,%d\n", pArgs->rangeFrom, pArgs->rangeTo);
                return -1;
            }
        } else if (strcmp(arg, "--remove-stops") == 0) {
            val = argv[++n];
            if (sscanf(val, "%le", &pArgs->minSpeed) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--rel-time") == 0) {
            val = argv[++n];
            int fmt = 0;
            if (sscanf(val, "%u", &fmt) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
            pArgs->relTime = fmt;
        } else if (strcmp(arg, "--set-speed") == 0) {
            val = argv[++n];
            if (sscanf(val, "%le", &pArgs->setSpeed) != 1) {
                invalidArgument(arg, val);
                return -1;
            }
            pArgs->setSpeed = (pArgs->setSpeed / 3.6);  // convert from km/h to m/s
        } else if (strcmp(arg, "--sma-window") == 0) {
            val = argv[++n];
            if ((sscanf(val, "%d", &pArgs->smaWindow) != 1) ||
                ((pArgs->smaWindow % 2) == 0)) {
                invalidArgument(arg, val);
                return -1;
            }
        } else if (strcmp(arg, "--start-time") == 0) {
            val = argv[++n];
            struct tm brkDwnTime = {0};
            time_t time0;
            if (strcmp(val, "now") == 0) {
                time0 = time(NULL);
            } else if (strptime(val, "%Y-%m-%dT%H:%M:%S", &brkDwnTime) != NULL) {
                time0 = mktime(&brkDwnTime);
            } else {
                invalidArgument(arg, val);
                return -1;
            }
            pArgs->startTime = (double) time0;
        } else if (strcmp(arg, "--summary") == 0) {
            pArgs->summary = true;
            pArgs->relTime = seconds;   // force relative timestamps
        } else if (strcmp(arg, "--trim") == 0) {
            pArgs->trim = true;
        } else if (strcmp(arg, "--verbatim") == 0) {
            pArgs->verbatim = true;
        } else if (strcmp(arg, "--version") == 0) {
            fprintf(stdout, "Version %s %s\n", PROGRAM_VERSION, buildInfo);
            exit(0);
        } else if (strncmp(arg, "--", 2) == 0) {
            fprintf(stderr, "Invalid option: %s\n", arg);
            return -1;
        } else {
            // Assume it's the input file(s)
            break;
        }
    }

    pArgs->argc = argc;
    pArgs->argv = argv;

    if (pArgs->outFile == NULL) {
        // By default send output to stdout
        pArgs->outFile = stdout;
    }

    if (pArgs->outFmt == nil) {
        // By default use GPX output format
        pArgs->outFmt = gpx;
    }

    if (pArgs->type == 0) {
        // By default use a Ride activity type
        pArgs->type = 1;
    }

    return n;
}

static void printTrkPt(TrkPt *p)
{
    fprintf(stderr, "TrkPt #%u at %s:%u {\n", p->index, p->inFile, p->lineNum);
    fprintf(stderr, "  latitude=%.10lf longitude=%.10lf elevation=%.10lf time=%.3lf speed=%.3lf grade=%.2lf\n",
            p->latitude, p->longitude, p->elevation, p->time, p->speed, p->grade);
    fprintf(stderr, "}\n");
}

// Dump the specified number of track points before and
// after the given TrkPt.
static void dumpTrkPts(GpsTrk *pTrk, TrkPt *p, int numPtsBefore, int numPtsAfter)
{
    int i;
    TrkPt *tp;

    // Rewind numPtsBefore points...
    for (i = 0, tp = p; (i < numPtsBefore) && (tp != NULL); i++) {
        tp = TAILQ_PREV(tp, TrkPtList, tqEntry);
    }

    // Points before the given point
    while (tp != p) {
        printTrkPt(tp);
        tp = TAILQ_NEXT(tp, tqEntry);
    }

    // The point in question
    printTrkPt(p);

    // Points after the given point
    for (i = 0, tp = TAILQ_NEXT(p, tqEntry); (i < numPtsAfter) && (tp != NULL); i++, tp = TAILQ_NEXT(tp, tqEntry)) {
        printTrkPt(tp);
    }
}

static int getLine(FILE *fp, char *lineBuf, size_t bufLen, int lineNum)
{
    if (fgets(lineBuf, bufLen, fp) == NULL)
        return -1;

    return ++lineNum;
}

// Parse the GPX file and create a list of Track Points
//
// <trkpt lat="39.7374080" lon="-105.5244740">
//   <ele>2309.2</ele>
//   <time>2021-09-30T22:09:49Z</time>
//   <extensions>
//     <power>186</power>
//     <gpxtpx:TrackPointExtension>
//       <gpxtpx:hr>115</gpxtpx:hr>
//       <gpxtpx:cad>61</gpxtpx:cad>
//     </gpxtpx:TrackPointExtension>
//   </extensions>
// </trkpt>
//
static int parseGpxFile(CmdArgs *pArgs, GpsTrk *pTrk)
{
    FILE *fp;
    TrkPt *pTrkPt = NULL;
    TrkPt *prevTrkPt = NULL;
    const char *inFile = pArgs->inFile;
    int lineNum = 0;
    int metaData = 0;
    int trimTrkPts = false;
    double trimmedTime = 0.0;
    static char lineBuf[4096];

    // Open the GPX file for reading
    if ((fp = fopen(inFile, "r")) == NULL) {
        fprintf(stderr, "Failed to open input file %s\n", inFile);
        return -1;
    }

    // Validate the input file. Expected format is:
    //
    // <?xml ...>
    // <gpx ...>
    //   .
    //   .
    //   .
    // </gpx>
    //
    lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum);
    if ((lineNum < 0) ||
        (strstr(lineBuf, "<?xml ") == NULL)) {
        fprintf(stderr, "Input file is not an XML file !!!\n");
        return -1;
    }
    lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum);
    if ((lineNum < 0) ||
        (strstr(lineBuf, "<gpx ") == NULL)) {
        fprintf(stderr, "Input file is not a recognized GPX file !!!\n");
        return -1;
    }

    // Process one line at a time, looking for <trkpt> ... </trkpt>
    // blocks that define a track point.
    while (fgets(lineBuf, sizeof(lineBuf), fp) != NULL) {
        double latitude, longitude, elevation;
        struct tm brkDwnTime = {0};
        int ambTemp, cadence, heartRate, power;
        const char *p;

        lineNum++;

        //fprintf(stdout, "%u: %s", lineNum, lineBuf);

        // Ignore the metadata
        if (strstr(lineBuf, "<metadata>") != NULL) {
            metaData++;
            continue;
        } else if (strstr(lineBuf, "</metadata>") != NULL) {
            metaData--;
            continue;
        } else if (metaData) {
            continue;
        }

        if ((sscanf(lineBuf, " <trkpt lat=\"%le\" lon=\"%le\">", &latitude, &longitude) == 2) ||
            (sscanf(lineBuf, " <trkpt lon=\"%le\" lat=\"%le\">", &longitude, &latitude) == 2)) {
            // New Track Point!
            if (pTrkPt != NULL) {
                // Hu?
                fprintf(stderr, "SPONG! Nested <trkpt> block !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }

            // Update absolute TrkPt index. This index increases
            // monotonically, even for TrkPts that are trimmed out.
            pTrk->index++;

            if ((pTrkPt = calloc(1, sizeof(TrkPt))) == NULL) {
                fprintf(stderr, "Failed to alloc TrkPt object !!!\n");
                return -1;
            }

            pTrkPt->inFile = inFile;
            pTrkPt->lineNum = lineNum;
            pTrkPt->latitude = latitude;
            pTrkPt->longitude = longitude;
        } else if (sscanf(lineBuf, " <ele>%le</ele>", &elevation) == 1) {
            // Got the elevation!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
            pTrkPt->elevation = elevation;
        } else if ((p = strptime(lineBuf, " <time>%Y-%m-%dT%H:%M:%S", &brkDwnTime)) != NULL) {
            time_t timeStamp;
            int ms = 0;

            // Got the time!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }

            // Convert to seconds since the Epoch
            timeStamp = mktime(&brkDwnTime);

            // If present, read the millisec portion
            if (sscanf(p, ".%d", &ms) == 1) {
                if ((ms < 0) || (ms > 999)) {
                    fprintf(stderr, "Invalid millisec value %d in timestamp !!! %s:%u \"%s\"\n", ms, inFile, lineNum, lineBuf);
                    return -1;
                }
            }

            pTrkPt->time = (double) timeStamp + ((double) ms / 1000.0);  // seconds+millisec since the Epoch
        } else if (sscanf(lineBuf, " <power>%d</power>", &power) == 1) {
            // Got the power!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
            pTrkPt->power = power;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:atemp>%d</gpxtpx:atemp>", &ambTemp) == 1) {
            // Got the ambient temperature!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
            pTrkPt->ambTemp = ambTemp;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:cad>%d</gpxtpx:cad>", &cadence) == 1) {
            // Got the cadence!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
            pTrkPt->cadence = cadence;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:hr>%d</gpxtpx:hr>", &heartRate) == 1) {
            // Got the heart rate!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
            pTrkPt->heartRate = heartRate;
            pTrk->optTagCount++;
        } else if (strstr(lineBuf, "</trkpt>") != NULL) {
            // End of Track Point!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> block !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }

            // Let's do some consistency checks...

            // Without elevation data, there isn't much we can do!
            if (pTrkPt->elevation == 0.0) {
                fprintf(stderr, "TrkPt %s:%u is missing its elevation data !\n", pTrkPt->inFile, pTrkPt->lineNum);
                return -1;
            }

            if (pTrkPt->time == 0.0) {
                // The only case when we allow TrkPt's without a
                // timestamp is when we are processing a GPX route
                // file, to convert it into a GPX ride file, in
                // which case a desired average speed should have
                // been specified, in order to compute the timing
                // data...
                if (pArgs->setSpeed == 0.0) {
                    fprintf(stderr, "TrkPt %s:%u is missing its time data !\n", pTrkPt->inFile, pTrkPt->lineNum);
                    return -1;
                }
            } else {
                // Timestamps should increase monotonically
                if ((prevTrkPt != NULL) && (pTrkPt->time <= prevTrkPt->time)) {
                    fprintf(stderr, "TrkPt %s:%u has a non-increasing timestamp from the previous point at line #%u !\n",
                            pTrkPt->inFile, pTrkPt->lineNum, prevTrkPt->lineNum);
                    return -1;
                }
            }

            // Discard any duplicate points, and any points
            // in the specified range ...
            {
                Bool discTrkPt = false;

                if (!pArgs->verbatim) {
                    // Some GPX tracks may have duplicate TrkPt's
                    if ((prevTrkPt != NULL) &&
                        (prevTrkPt->latitude == pTrkPt->latitude) &&
                        (prevTrkPt->longitude == pTrkPt->longitude) &&
                        (prevTrkPt->elevation == pTrkPt->elevation)) {
                        if (!pArgs->quiet) {
                            fprintf(stderr, "WARNING: TrkPt at line %s:%u is a duplicate of TrkPt at line #%u !\n",
                                    pTrkPt->inFile, pTrkPt->lineNum, prevTrkPt->lineNum);
                        }
                        pTrk->numDupTrkPts++;
                        discTrkPt = true;
                    }
                }

                // Do we need to trim this TrkPt?
                if (pArgs->trim) {
                    if (pTrk->index == pArgs->rangeFrom) {
                        // Start trimming
                        trimTrkPts = true;
                        trimmedTime = pTrkPt->time;  // set baseline time
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    } else if (pTrk->index == pArgs->rangeTo) {
                        // Stop trimming
                        trimTrkPts = false;
                        trimmedTime = pTrkPt->time - trimmedTime + 1;    // total time trimmed out
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    } else if (trimTrkPts) {
                        // Trim this point
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    }
                }

                // Discard?
                if (discTrkPt) {
                    free(pTrkPt);
                    pTrkPt = NULL;
                    continue;
                }
            }

            // This TrkPt has been "accepted" !

            pTrkPt->index = ++pTrk->trkPtNum;

            if (trimmedTime) {
                // If we trimmed out some points, move the timestamp
                // of this TrkPt back in time to "close the gap".
                pTrkPt->time -= trimmedTime;
            }

            // Insert track point at the tail of the queue and update
            // the TrkPt count.
            TAILQ_INSERT_TAIL(&pTrk->trkPtList, pTrkPt, tqEntry);
            pTrk->numTrkPts++;

            prevTrkPt = pTrkPt;
            pTrkPt = NULL;
        } else {
            // Ignore this line...
        }
    }

    fclose(fp);

    return 0;
}

// Parse the TCX file and create a list of Track Points
//
// <Trackpoint>
//   <Time>2021-09-30T22:09:49Z</Time>
//   <Position>
//     <LatitudeDegrees>39.737408</LatitudeDegrees>
//     <LongitudeDegrees>-105.524474</LongitudeDegrees>
//   </Position>
//   <AltitudeMeters>2309.2</AltitudeMeters>
//   <HeartRateBpm>
//     <Value>115</Value>
//   </HeartRateBpm>
//   <Cadence>61</Cadence>
//   <Extensions>
//     <TPX xmlns="http://www.garmin.com/xmlschemas/ActivityExtension/v2">
//       <Watts>186</Watts>
//     </TPX>
//   </Extensions>
// </Trackpoint>
//
static int parseTcxFile(CmdArgs *pArgs, GpsTrk *pTrk)
{
    FILE *fp;
    TrkPt *pTrkPt = NULL;
    TrkPt *prevTrkPt = NULL;
    const char *inFile = pArgs->inFile;
    int lineNum = 0;
    int trackBlock = false;
    int trimTrkPts = false;
    double trimmedTime = 0.0;
    static char lineBuf[4096];

    // Open the TCX file for reading
    if ((fp = fopen(inFile, "r")) == NULL) {
        fprintf(stderr, "Failed to open input file %s\n", inFile);
        return -1;
    }

    // Validate the input file. Expected format is:
    //
    // <?xml ...>
    // <TrainingCenterDatabase  ...>
    //   .
    //   .
    //   .
    // </TrainingCenterDatabase>
    //
    lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum);
    if ((lineNum < 0) ||
        (strstr(lineBuf, "<?xml ") == NULL)) {
        fprintf(stderr, "Input file is not an XML file: lineBuf=%s lineNum=%u\n", lineBuf, lineNum);
        return -1;
    }
    lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum);
    if ((lineNum < 0) ||
        (strstr(lineBuf, "<TrainingCenterDatabase") == NULL)) {
        fprintf(stderr, "Input file is not a recognized TCX file: lineBuf=%s lineNum=%u\n", lineBuf, lineNum);
        return -1;
    }

    // Process one line at a time, looking for <Trackpoint> ... </Trackpoint>
    // blocks that define a track point.
    while ((lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum)) != -1) {
        double latitude, longitude, elevation;
        struct tm brkDwnTime = {0};
        int cadence, heartRate, power;
        const char *p;

        //fprintf(stdout, "%u: %s", lineNum, lineBuf);

        if (strstr(lineBuf, " <Track>") != NULL) {
            if (!trackBlock) {
                // Start of a <Track> ... </Track> block
                trackBlock = true;
            } else {
                // Hu?
                fprintf(stderr, "SPONG! Nested <Track> block !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
        } else if (strstr(lineBuf, " </Track>") != NULL) {
            if (trackBlock) {
                // End of a <Track> ... </Track> block
                trackBlock = false;
            } else {
                // Hu?
                fprintf(stderr, "SPONG! Bogus </Track> tag !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                return -1;
            }
        } else if (trackBlock) {
            if (strstr(lineBuf, " <Trackpoint>") != NULL) {
                // New Track Point!
                if (pTrkPt != NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! Nested <Trackpoint> block !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }

                // Update absolute TrkPt index. This index increases
                // monotonically, even for TrkPts that are trimmed out.
                pTrk->index++;

                if ((pTrkPt = calloc(1, sizeof(TrkPt))) == NULL) {
                    fprintf(stderr, "Failed to alloc TrkPt object !!!\n");
                    return -1;
                }

                pTrkPt->inFile = inFile;
                pTrkPt->lineNum = lineNum;
            } else if (sscanf(lineBuf, " <LatitudeDegrees>%le</LatitudeDegrees>", &latitude) == 1) {
                // Got the latitude!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }
                pTrkPt->latitude = latitude;
            } else if (sscanf(lineBuf, " <LongitudeDegrees>%le</LongitudeDegrees>", &longitude) == 1) {
                // Got the longitude!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }
                pTrkPt->longitude = longitude;
            } else if (sscanf(lineBuf, " <AltitudeMeters>%le</AltitudeMeters>", &elevation) == 1) {
                // Got the elevation!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }
                pTrkPt->elevation = elevation;
            } else if ((p = strptime(lineBuf, " <Time>%Y-%m-%dT%H:%M:%S", &brkDwnTime)) != NULL) {
                time_t timeStamp;
                int ms = 0;

                // Got the time!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }

                // Convert to seconds since the Epoch
                timeStamp = mktime(&brkDwnTime);

                // If present, read the millisec portion
                if (sscanf(p, ".%d", &ms) == 1) {
                    if ((ms < 0) || (ms > 999)) {
                        fprintf(stderr, "Invalid millisec value %d in timestamp !!! %s:%u \"%s\"\n", ms, inFile, lineNum, lineBuf);
                        return -1;
                    }
                }

                pTrkPt->time = (double) timeStamp + ((double) ms / 1000.0);  // seconds+millisec since the Epoch
            } else if (sscanf(lineBuf, " <Watts>%d</Watts>", &power) == 1) {
                // Got the power!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }
                pTrkPt->power = power;
                pTrk->optTagCount++;
            } else if (sscanf(lineBuf, " <Cadence>%d</Cadence>", &cadence) == 1) {
                // Got the cadence!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }
                pTrkPt->cadence = cadence;
                pTrk->optTagCount++;
            } else if (strstr(lineBuf, " <HeartRateBpm") != NULL) {
                lineNum = getLine(fp, lineBuf, sizeof (lineBuf), lineNum);
                if (sscanf(lineBuf, " <Value>%d</Value>", &heartRate) == 1) {
                    // Got the heart rate!
                    if (pTrkPt == NULL) {
                        // Hu?
                        fprintf(stderr, "SPONG! No active <Trackpoint> !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                        return -1;
                    }
                    pTrkPt->heartRate = heartRate;
                    pTrk->optTagCount++;
                }
            } else if (strstr(lineBuf, "</Trackpoint>") != NULL) {
                // End of Track Point!
                if (pTrkPt == NULL) {
                    // Hu?
                    fprintf(stderr, "SPONG! No active <Trackpoint> block !!! %s:%u \"%s\"\n", inFile, lineNum, lineBuf);
                    return -1;
                }

                // Let's do some consistency checks...

                // Without elevation data, there isn't much we can do!
                if (pTrkPt->elevation == 0.0) {
                    fprintf(stderr, "TrkPt %s:%u is missing its elevation data !\n", pTrkPt->inFile, pTrkPt->lineNum);
                    return -1;
                }

                if (pTrkPt->time == 0.0) {
                    // The only case when we allow TrkPt's without a
                    // timestamp is when we are processing a TCX route
                    // file, to convert it into a TCX ride file, in
                    // which case a desired average speed should have
                    // been specified, in order to be able to compute
                    // the timing data...
                    if (pArgs->setSpeed == 0.0) {
                        fprintf(stderr, "TrkPt %s:%u is missing its time data !\n", pTrkPt->inFile, pTrkPt->lineNum);
                        return -1;
                    }
                } else {
                    // Timestamps should increase monotonically
                    if ((prevTrkPt != NULL) && (pTrkPt->time <= prevTrkPt->time)) {
                        fprintf(stderr, "TrkPt %s:%u has a non-increasing timestamp from the previous point at line #%u !\n",
                                pTrkPt->inFile, pTrkPt->lineNum, prevTrkPt->lineNum);
                        return -1;
                    }
                }

                // Discard any duplicate points, and any points
                // in the specified range ...
                {
                    Bool discTrkPt = false;

                    if (!pArgs->verbatim) {
                        // Some GPX tracks may have duplicate TrkPt's
                        if ((prevTrkPt != NULL) &&
                            (prevTrkPt->latitude == pTrkPt->latitude) &&
                            (prevTrkPt->longitude == pTrkPt->longitude) &&
                            (prevTrkPt->elevation == pTrkPt->elevation)) {
                            if (!pArgs->quiet) {
                                fprintf(stderr, "WARNING: TrkPt at line %s:%u is a duplicate of TrkPt at line #%u !\n",
                                        pTrkPt->inFile, pTrkPt->lineNum, prevTrkPt->lineNum);
                            }
                            pTrk->numDupTrkPts++;
                            discTrkPt = true;
                        }
                    }

                    // Do we need to trim this TrkPt?
                    if (pArgs->trim) {
                        if (pTrk->index == pArgs->rangeFrom) {
                            // Start trimming
                            trimTrkPts = true;
                            trimmedTime = pTrkPt->time;  // set baseline time
                            pTrk->numTrimTrkPts++;
                            discTrkPt = true;
                        } else if (pTrk->index == pArgs->rangeTo) {
                            // Stop trimming
                            trimTrkPts = false;
                            trimmedTime = pTrkPt->time - trimmedTime + 1;    // total time trimmed out
                            pTrk->numTrimTrkPts++;
                            discTrkPt = true;
                        } else if (trimTrkPts) {
                            // Trim this point
                            pTrk->numTrimTrkPts++;
                            discTrkPt = true;
                        }
                    }

                    // Discard?
                    if (discTrkPt) {
                        free(pTrkPt);
                        pTrkPt = NULL;
                        continue;
                    }
                }

                // This TrkPt has been "accepted" !

                pTrkPt->index = ++pTrk->trkPtNum;

                if (trimmedTime) {
                    // If we trimmed out some points, move the timestamp
                    // of this TrkPt back in time to "close the gap".
                    pTrkPt->time -= trimmedTime;
                }

                // Insert track point at the tail of the queue and update
                // the TrkPt count.
                TAILQ_INSERT_TAIL(&pTrk->trkPtList, pTrkPt, tqEntry);
                pTrk->numTrkPts++;

                prevTrkPt = pTrkPt;
                pTrkPt = NULL;
            } else {
                // Ignore this line...
            }
        }
    }

    fclose(fp);

    return 0;
}

static int closeTimeGap(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = TAILQ_FIRST(&pTrk->trkPtList);  // previous TrkPt
    TrkPt *p2 = TAILQ_NEXT(p1, tqEntry);    // current TrkPt
    double timeGap = 0.0;

    while (p2 != NULL) {
        if (p2->index == pArgs->closeGap) {
            timeGap = p2->time - p1->time - 1.0;
        }

        if (timeGap != 0.0) {
            p2->time -= timeGap;
        }

        p1 = p2;
        p2 = TAILQ_NEXT(p2, tqEntry);
    }

    return 0;
}

// Compute the distance (in meters) between two track points
// using the Haversine formula. See:
//
//   https://en.wikipedia.org/wiki/Haversine_formula
//
// for the details.
static double compDistance(const TrkPt *p1, const TrkPt *p2)
{
    double latitude1 = p1->latitude * degToRad; // p1's latitude in radians
    double latitude2 = p2->latitude * degToRad; // p2's latitude in radians
    double latDiff = (p2->latitude - p1->latitude) * degToRad; // latitude diff in radians
    double lonDiff = (p2->longitude - p1->longitude) * degToRad; // longitude diff in radians
    double a;
    double c;

    a = pow(sin(latDiff/2), 2) + cos(latitude1) * cos(latitude2) * pow(sin(lonDiff/2), 2);
    assert(a <= 1.0);
    c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));

    return (c * earthMeanRadius);
}

// Given a fixed distance (deltaP) figure out what the
// elevation difference (deltaE) should be, in order to
// get the desired grade value, and adjust the elevation
// value accordingly.
//
//   deltaE^2 = (grade^2 x deltaP^2) / (1 + grade^2)
//
static void adjElevation(GpsTrk *pTrk, TrkPt *p1, TrkPt *p2)
{
    double grade = (p2->grade / 100.0); // desired grade in decimal (0.00 .. 1.00)
    double grade2 = (grade * grade);    // grade squared
    double deltaP2 = (p2->deltaP * p2->deltaP); // deltaP squared
    double rise = sqrt((grade2 * deltaP2) / (1.0 + grade2));
    double adjElev;

    if (p2->deltaE >= 0.0) {
        p2->deltaE = rise;
    } else {
        p2->deltaE = (0.0 - rise);
    }
    adjElev = p1->elevation + p2->deltaE;
    if (adjElev != p2->elevation) {
        p2->elevation = adjElev;
        pTrk->numElevAdj++;
    }
}

static int compDataPhase1(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = TAILQ_FIRST(&pTrk->trkPtList);  // previous TrkPt
    TrkPt *p2 = TAILQ_NEXT(p1, tqEntry);    // current TrkPt

    // Compute the distance, elevation diff, speed, and grade
    // between each pair of points...
    while (p2 != NULL) {
        Bool stopped = false;

        // Compute the position difference (distance) between
        // the two points.
        p2->deltaP = compDistance(p1, p2);

        if (pArgs->maxTimeGap != 0) {
            // Limit the time gap to the max specified value
            double timeGap = p2->time - p1->time;
            if (timeGap > pArgs->maxTimeGap) {
                fprintf(stderr, "INFO: TrkPt #%u at %s:%u has a deltaT=%.3lf that exceeds the max time gap!\n",
                        p2->index, p2->inFile, p2->lineNum, timeGap);
                p2->time = p1->time + pArgs->maxTimeGap;
            }
        }

#if 0
        if (p2->deltaP == 0.0) {
            // If deltaP is zero, it likely means we were not
            // moving. But if there is a difference in elevation
            // value from the previous point, it may mean that
            // there was a hiccup in the latitude and longitude
            // GPS values, and we were indeed moving. In that
            // case, use the speed of the previous TrkPt to
            // come up with the actual deltaP value.
            if ((p2->elevation != p1->elevation) && (p1->speed != 0.0)) {
                p2->deltaP = p1->deltaP;
            }
        }
#endif

        // Update the max distance between two points
        if (p2->deltaP > pTrk->maxDeltaP) {
            pTrk->maxDeltaP = p2->deltaP;
            pTrk->maxDeltaPTrkPt = p2;
        }

        if (p2->time == 0.0) {
            // TrkPt has no timestamp, so compute the time
            // interval deltaT based on the distance deltaP
            // (in m) and the specified speed (in m/s).
            double deltaT = (p2->deltaP / pArgs->setSpeed); // always positive
            if (deltaT == 0.0) {
                fprintf(stderr, "SPONG! TrkPt #%u at %s:%u has a null deltaT !\n",
                        p2->index, p2->inFile, p2->lineNum);
                dumpTrkPts(pTrk, p2, 2, 2);
                deltaT = 0.1;
            }
            p2->time = p1->time + deltaT;
        }

        // Compute the time interval between the two points.
        // Typically fixed at 1-sec, but some GPS devices (e.g.
        // Garmin Edge) may use a "smart" recording mode that
        // can have several seconds between points, while
        // other devices (e.g. GoPro Hero) may record multiple
        // points each second...
        p2->deltaT = (p2->time - p1->time);

        // Paranoia?
        if (p2->deltaT <= 0) {
            fprintf(stderr, "SPONG! TrkPt #%u at %s:%u has a non-increasing timestamp !\n",
                    p2->index, p2->inFile, p2->lineNum);
            dumpTrkPts(pTrk, p2, 2, 2);
        }

        // Compute the speed as "distance over time", and
        // convert it from m/s to km/h.
        p2->speed = ((p2->deltaP * 3.6) / p2->deltaT);

        // Are we stopped?
        if (p2->speed == 0.0) {
            stopped = true;
        } else if ((pArgs->minSpeed != 0.0) && (p2->speed < pArgs->minSpeed)) {
            // The speed is below the specified minimum value
            // so assume we are stopped.
            if (!pArgs->quiet) {
                fprintf(stderr, "WARNING: TrkPt #%u at %s:%u has a speed value %.10lf km/h below the minimum value %.10lf km/h. Assume stopped !\n",
                        p2->index, p2->inFile, p2->lineNum, p2->speed, pArgs->minSpeed);
            }

            stopped = true;
        } else {
            stopped = false;
        }

        if (stopped) {
            if (!pArgs->quiet) {
                fprintf(stderr, "INFO: Stopped! (TrkPt #%u at %s:%u, speed %.10lf km/h, deltaT %.3lf, stoppedTime %ld\n",
                        p2->index, p2->inFile, p2->lineNum, p2->speed, p2->deltaT, (time_t) pTrk->stoppedTime);
            }

            // Update the stopped time value for the activity
            pTrk->stoppedTime += p2->deltaT;

            if (!pArgs->verbatim) {
                // Set the speed to zero, to indicate we were not
                // moving, and skip this point when we generate
                // the output data.
                p2->speed = 0.0;
            }
        } else {
            if (!pArgs->verbatim) {
                // Adjust the timestamp to account for any stopped
                // time till this point.
                p2->adjTime = p2->time - pTrk->stoppedTime;
            }

            // Update the total distance for the activity
            pTrk->distance += p2->deltaP;

            // Set the distance (from the start) of this
            // point.
            p2->distance = pTrk->distance;

            // Update the total time for the activity
            pTrk->time += p2->deltaT;

            // Update the max time interval between two points
            if (p2->deltaT > pTrk->maxDeltaT) {
                pTrk->maxDeltaT = p2->deltaT;
                pTrk->maxDeltaTTrkPt = p2;
            }

            // Now let's compute the grade!
            {
                double distance = p2->deltaP;
                double rise;

                // Elevation difference (can be negative)
                p2->deltaE = p2->elevation - p1->elevation;

                // The rise is always positive!
                rise = fabs(p2->deltaE);

                // Use Pythagoras's Theorem to compute the horizontal
                // distance (run) based on the distance (hypotenuse)
                // and the elevation difference (rise). Notice that
                // the rise value inherits whatever error the elevation
                // value may have. Notice also that the drawing of the
                // triangle below is not realistic, as even with a
                // steep 25% grade, a run of 1 meter would have a rise
                // of only 0.25 meter, so the triangle would typically
                // have a longer run than rise, being "long and short"
                // when drawn to scale.
                //
                //                 p2 +
                //                   /|
                //                  / |
                //                 /  |
                //       distance /   | rise
                //               /    |
                //              /     |
                //             /      |
                //         p1 +-------+
                //               run
                //
                //    run^2 + rise^2 = distance^2
                //
                // Under normal circumstances, the distance is always
                // larger than the rise.  But when the GPS elevation
                // data is bad, the rise value may be larger than the
                // distance, in which case Pythagoras's Theorem would
                // not work anymore. In those cases we "fix" the rise
                // value using the grade value of the previous point
                // as a reference.
                if (distance < rise) {
                    if (!pArgs->quiet) {
                        fprintf(stderr, "WARNING: TrkPt #%u at %s:%u has inconsistent distance (%.10lf) and rise (%.10lf) values! (speed=%.3lf km/h)\n",
                                p2->index, p2->inFile, p2->lineNum, distance, rise, p2->speed);
                        dumpTrkPts(pTrk, p2, 2, 2);
                    }
                    p2->grade = p1->grade;
                    adjElevation(pTrk, p1, p2);
                    rise = fabs(p2->deltaE);
                    if (!pArgs->quiet) {
                        fprintf(stderr, "WARNING: Adjusted values: distance (%.10lf) rise (%.10lf) grade (%.2lf)\n",
                                distance, rise, p2->grade);
                    }
                }

                {
                    double runSquare = (distance * distance) - (rise * rise);

                    if (runSquare > 0.0) {
                        p2->run = sqrt(runSquare);
                    } else {
                        // Hu? This should not happen!
                        fprintf(stderr, "SPONG! TrkPt #%u at %s:%u has a negative runSquare value ! (distance=%.10lf rise=%.10lf runSquare=%.10lf)\n",
                                p2->index, p2->inFile, p2->lineNum, distance, rise, runSquare);
                        dumpTrkPts(pTrk, p2, 2, 2);
                        return -1;
                    }

                    if (p2->run != 0.0) {
                        // Compute the grade as "rise over run". Here we use deltaE
                        // instead of rise, so that the grade value has the right
                        // sign...
                        p2->grade = (p2->deltaE * 100.0) / p2->run;  // in [%]
                    } else {
                        // Hu? This should not happen!
                        if (!pArgs->quiet) {
                            fprintf(stderr, "WARNING: TrkPt #%u at %s:%u has a null run value !\n",
                                    p2->index, p2->inFile, p2->lineNum);
                            dumpTrkPts(pTrk, p2, 2, 2);
                        }

                        // Use the values from the previous point
                        p2->elevation = p1->elevation;
                        p2->speed = p1->speed;
                        p2->grade = p1->grade;
                    }
                }
            }
        }

        p1 = p2;
        p2 = TAILQ_NEXT(p2, tqEntry);
    }

    return 0;
}

// Compute the Simple Moving Average (SMA) of the grade value
// of the given point. The SMA uses a window size of N points,
// where N is an odd value. The average is computed using the
// (N-1)/2 values before the point, the value of the point,
// and the (N-1)/2 values after the point. Notice that for the
// first few points and for the last few points in the track,
// the SMA is computed over fewer than N points.
//
//   <-- (N-1)/2 --> <-- (N-1)/2 -->
//   +--------------+---------------+
//                  p
//
static void compGradeSma(GpsTrk *pTrk, TrkPt *p, int smaWindow)
{
    int i;
    int n = (smaWindow - 1) / 2;
    int numPoints = 1;
    double gradeSum = p->grade;
    TrkPt *tp;

    // Points before the given point
    for (i = 0, tp = TAILQ_PREV(p, TrkPtList, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_PREV(tp, TrkPtList, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Points after the given point
    for (i = 0, tp = TAILQ_NEXT(p, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_NEXT(tp, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Override the original grade value with the
    // computed SMA value.
    p->grade = gradeSum / numPoints;

    // Flag that this point had its grade adjusted
    p->adjGrade = true;
}

static int pointWithinRange(const CmdArgs *pArgs, const TrkPt *p)
{
    if (pArgs->rangeFrom == 0) {
        // No actual range specified, so all points
        // are within range...
        return true;
    }

    if ((p->index >= pArgs->rangeFrom) && (p->index <= pArgs->rangeTo)) {
        // Point is within specified range
        return true;
    }

    return false;
}

static void adjMaxGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt %s:%u has a grade of %.2lf%% that exceeds the max value %.2lf%% !\n",
                p2->inFile, p2->lineNum, p2->grade, pArgs->maxGrade);
    }

    // Override original value with the max value
    p2->grade = pArgs->maxGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static void adjMinGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt %s:%u has a grade of %.2lf%% that exceeds the min value %.2lf%% !\n",
                p2->inFile, p2->lineNum, p2->grade, pArgs->minGrade);

    }

    // Override original value with the min value
    p2->grade = pArgs->minGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static int compDataPhase2(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = NULL;   // previous TrkPt
    TrkPt *p2 = NULL;   // current TrkPt

    TAILQ_FOREACH(p2, &pTrk->trkPtList, tqEntry) {
        if (p1 != NULL) {
            // Skip points where we were stopped
            if (p2->speed != 0.0) {
                // Do we need to smooth out the grade values?
                if (pArgs->smaWindow != 0) {
                    compGradeSma(pTrk, p2, pArgs->smaWindow);
                }

                // See if we need to limit the max grade values
                if ((pArgs->maxGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade > pArgs->maxGrade)) {
                    adjMaxGrade(pTrk, pArgs, p1, p2);
                }

                // See if we need to limit the min grade values
                if ((pArgs->minGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade < pArgs->minGrade)) {
                    adjMinGrade(pTrk, pArgs, p1, p2);
                }

                // If necessary, correct the elevation value based
                // on the adjusted grade value. We need to adjust
                // the value of delatE, while the value of deltaP
                // remains invariant; i.e. the deltaP vector needs
                // to rotate along an arc so that the tanget of the
                // angle 'alpha' with the horizontal (run) results
                // in the adjusted/desired grade value.
                if (p2->adjGrade) {
                    adjElevation(pTrk, p1, p2);
                }

                // Update the rolling elevation gain/loss values
                if (p2->deltaE >= 0) {
                    pTrk->elevGain += p2->deltaE;
                } else {
                    pTrk->elevLoss -= p2->deltaE;
                }

                // Update the min/max values
                if (p2->speed > pTrk->maxSpeed) {
                     pTrk->maxSpeed = p2->speed;
                     pTrk->maxSpeedTrkPt = p2;
                }
                if (p2->grade > pTrk->maxGrade) {
                     pTrk->maxGrade = p2->grade;
                     pTrk->maxGradeTrkPt = p2;
                } else if (p2->grade < pTrk->minGrade) {
                    pTrk->minGrade = p2->grade;
                    pTrk->minGradeTrkPt = p2;
                }
            }
        }

        p1 = p2;
    }

    return 0;
}

static const char *fmtTimeStamp(time_t ts, TsFmt fmt)
{
    static char fmtBuf[64];

    if (fmt == hhmmss) {
        time_t time = ts;
        time_t hr, min, sec;
        hr = time / 3600;
        min = (time - (hr * 3600)) / 60;
        sec = (time - (hr * 3600) - (min * 60));
        snprintf(fmtBuf, sizeof (fmtBuf), "%02ld:%02ld:%02ld", hr, min, sec);
    } else {
        snprintf(fmtBuf, sizeof (fmtBuf), "%ld", ts);
    }

    return fmtBuf;
}

static void printSummary(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t time;
    const TrkPt *p;

    fprintf(pArgs->outFile, "    numTrkPts: %d\n", pTrk->numTrkPts);
    fprintf(pArgs->outFile, " numDupTrkPts: %d\n", pTrk->numDupTrkPts);
    fprintf(pArgs->outFile, "numTrimTrkPts: %d\n", pTrk->numTrimTrkPts);
    fprintf(pArgs->outFile, "   numElevAdj: %d\n", pTrk->numElevAdj);

    // Date & time
    {
        double timeStamp;
        struct tm brkDwnTime = {0};
        char timeBuf[128];
        time_t dateAndTime;

        p = TAILQ_FIRST(&pTrk->trkPtList);
        timeStamp = (p->adjTime != 0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
        timeStamp += pTrk->timeOffset;
        dateAndTime = (time_t) timeStamp;  // seconds only
        strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&dateAndTime, &brkDwnTime));
        fprintf(pArgs->outFile, "  dateAndTime: %s\n", timeBuf);
    }

    // Elapsed time
    time = pTrk->endTime - pTrk->startTime;
    fprintf(pArgs->outFile, "  elapsedTime: %s\n", fmtTimeStamp(time, hhmmss));

    // Total time
    time = pTrk->time;
    fprintf(pArgs->outFile, "    totalTime: %s\n", fmtTimeStamp(time, hhmmss));

    // Moving time
    time = pTrk->time - pTrk->stoppedTime;
    fprintf(pArgs->outFile, "   movingTime: %s\n", fmtTimeStamp(time, hhmmss));

    // Stopped time
    time = pTrk->stoppedTime;
    fprintf(pArgs->outFile, "  stoppedTime: %s\n", fmtTimeStamp(time, hhmmss));

    fprintf(pArgs->outFile, "     distance: %.10lf km\n", (pTrk->distance / 1000.0));
    fprintf(pArgs->outFile, "     elevGain: %.10lf m\n", pTrk->elevGain);
    fprintf(pArgs->outFile, "     elevLoss: %.10lf m\n", pTrk->elevLoss);
    if ((p = pTrk->maxDeltaPTrkPt) != NULL) {
        fprintf(pArgs->outFile, "    maxDeltaP: %.3lf m at TrkPt #%d (%s:%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxDeltaP, p->index, p->inFile, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxDeltaTTrkPt) != NULL) {
        fprintf(pArgs->outFile, "    maxDeltaT: %.3lf sec at TrkPt #%d (%s:%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxDeltaT, p->index, p->inFile, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxSpeedTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     maxSpeed: %.10lf km/h at TrkPt #%d (%s:%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxSpeed, p->index, p->inFile, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     maxGrade: %.2lf%% at TrkPt #%d (%s:%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxGrade, p->index, p->inFile, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->minGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     minGrade: %.2lf%% at TrkPt #%d (%s:%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->minGrade, p->index, p->inFile, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
}

static void printCsvFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p;

    // Print column banner line
    fprintf(pArgs->outFile, "<inFile>,<line#>,<trkpt>,<time>,<lat>,<lon>,<ele>,");
    fprintf(pArgs->outFile, "<power>,<atemp>,<cadence>,<hr>,<deltaP>,<deltaT>,<deltaE>,run,<distance>,<speed>,<grade>\n");


    TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
        // Skip points where we were stopped
        if (p->speed != 0.0) {
            double timeStamp = (p->adjTime != 0.0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
            fprintf(pArgs->outFile, "%s,%d,%d,%s,%.10lf,%.10lf,%.10lf,",
                    p->inFile,                      // <inFile>
                    p->lineNum,                     // <line#>
                    p->index,                       // <trkPt>
                    fmtTimeStamp((timeStamp - pTrk->baseTime), pArgs->relTime),   // <time>
                    p->latitude,                    // <lat>
                    p->longitude,                   // <lon>
                    p->elevation);                  // <ele>
            fprintf(pArgs->outFile, "%d,%d,%d,%d,%.10lf,%.3lf,%.10lf,%.10lf,%.10lf,%.10lf,%.2lf\n",
                    p->power,                       // <power>
                    p->ambTemp,                     // <atemp>
                    p->cadence,                     // <cadence>
                    p->heartRate,                   // <hr>
                    p->deltaP,                      // <deltaP>
                    p->deltaT,                      // <deltaT>
                    p->deltaE,                      // <deltaE>
                    p->run,                         // <run>
                    (p->distance / 1000.0),         // <distance>
                    p->speed,                       // <speed>
                    p->grade);                      // <grade>
        }
    }
}

static void printGpxFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t now;
    struct tm brkDwnTime = {0};
    char timeBuf[128];

    // Print headers
    fprintf(pArgs->outFile, "%s", xmlHeader);
    fprintf(pArgs->outFile, gpxHeader, PROGRAM_VERSION);

    // Print metadata
    now = time(NULL);
    strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&now, &brkDwnTime));
    fprintf(pArgs->outFile, "  <metadata>\n");
    fprintf(pArgs->outFile, "    <name> ...  </name>\n");
    fprintf(pArgs->outFile, "    <desc> numTrkPts=%d numDupTrkPts=%d numTrimTrkPts=%d numElevAdj=%d </desc>\n",
            pTrk->numTrkPts, pTrk->numDupTrkPts, pTrk->numTrimTrkPts, pTrk->numElevAdj);
    fprintf(pArgs->outFile, "    <author>gpxFileTool version %s [https://github.com/elfrances/gpxFileTool.git]</author>\n", PROGRAM_VERSION);
    fprintf(pArgs->outFile, "    <time>%s</time>\n", timeBuf);
    fprintf(pArgs->outFile, "  </metadata>\n");

    // Print track
    fprintf(pArgs->outFile, "  <trk>\n");
    if (pArgs->name != NULL) {
        fprintf(pArgs->outFile, "    <name>%s</name>\n", pArgs->name);
    }
    fprintf(pArgs->outFile, "    <type>%d</type>\n", pArgs->type);

    // Print track segment
    fprintf(pArgs->outFile, "    <trkseg>\n");
    {
        TrkPt *p;

        // Print all the track points
        TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
            // Skip points where we were stopped
            if (p->speed != 0.0) {
                double timeStamp = (p->adjTime != 0.0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
                time_t time;
                int ms = 0;

                timeStamp += pTrk->timeOffset;
                time = (time_t) timeStamp;  // seconds only
                ms = (timeStamp - (double) time) * 1000.0;  // milliseconds
                strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&time, &brkDwnTime));
                fprintf(pArgs->outFile, "      <trkpt lat=\"%.10lf\" lon=\"%.10lf\">\n", p->latitude, p->longitude);
                fprintf(pArgs->outFile, "        <ele>%.10lf</ele>\n", p->elevation);
                fprintf(pArgs->outFile, "        <time>%s.%03dZ</time>\n", timeBuf, ms);

                // Now the optional metrics, if any...
                if ((pTrk->optTagCount != 0) && (pArgs->outMask != OM_NONE)) {
                    fprintf(pArgs->outFile, "        <extensions>\n");
                    if (pArgs->outMask & OM_POWER) {
                        fprintf(pArgs->outFile, "          <power>%d</power>\n", p->power);
                    }
                    if (pArgs->outMask & (OM_ATEMP | OM_CADENCE | OM_HR)) {
                        fprintf(pArgs->outFile, "          <gpxtpx:TrackPointExtension>\n");
                        if (pArgs->outMask & OM_ATEMP) {
                            fprintf(pArgs->outFile, "            <gpxtpx:atemp>%d</gpxtpx:atemp>\n", p->ambTemp);
                        }
                        if (pArgs->outMask & OM_CADENCE) {
                            fprintf(pArgs->outFile, "            <gpxtpx:cad>%d</gpxtpx:cad>\n", p->cadence);
                        }
                        if (pArgs->outMask & OM_HR) {
                            fprintf(pArgs->outFile, "            <gpxtpx:hr>%d</gpxtpx:hr>\n", p->heartRate);
                        }
                        fprintf(pArgs->outFile, "          </gpxtpx:TrackPointExtension>\n");
                    }
                    fprintf(pArgs->outFile, "        </extensions>\n");
                }

                fprintf(pArgs->outFile, "      </trkpt>\n");
            }
        }
    }
    fprintf(pArgs->outFile, "    </trkseg>\n");

    fprintf(pArgs->outFile, "  </trk>\n");

    fprintf(pArgs->outFile, "</gpx>\n");
}

static void printTcxFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t now;
    struct tm brkDwnTime = {0};
    char timeBuf[128];

    // Print headers
    fprintf(pArgs->outFile, "%s", xmlHeader);
    fprintf(pArgs->outFile, "%s", tcxHeader);

    // Print metadata
    now = time(NULL);
    strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&now, &brkDwnTime));

    fprintf(pArgs->outFile, "  <Activities>\n");
    fprintf(pArgs->outFile, "    <Activity Sport=\"Biking\">\n");
    fprintf(pArgs->outFile, "      <Id>%s</Id>\n", timeBuf);
    fprintf(pArgs->outFile, "      <Lap StartTime=\"%s\">\n", timeBuf);
    fprintf(pArgs->outFile, "        <Track>\n");
    {
        TrkPt *p;

        // Print all the track points
        TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
            // Skip points where we were stopped
            if (p->speed != 0.0) {
                double timeStamp = (p->adjTime != 0.0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
                time_t time;
                int ms = 0;

                timeStamp += pTrk->timeOffset;
                time = (time_t) timeStamp;  // seconds only
                ms = (timeStamp - (double) time) * 1000.0;  // milliseconds
                strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&time, &brkDwnTime));

                fprintf(pArgs->outFile, "          <Trackpoint>\n");
                fprintf(pArgs->outFile, "            <Time>%s.%03dZ</Time\n", timeBuf, ms);
                fprintf(pArgs->outFile, "            <Position>\n");
                fprintf(pArgs->outFile, "              <LatitudeDegrees>%.10lf</LatitudeDegrees>\n", p->latitude);
                fprintf(pArgs->outFile, "              <LongitudeDegrees>%.10lf</LongitudeDegrees>\n", p->longitude);
                fprintf(pArgs->outFile, "            </Position>\n");
                fprintf(pArgs->outFile, "            <AltitudeMeters>%.10lf</AltitudeMeters>\n", p->elevation);
                fprintf(pArgs->outFile, "            <DistanceMeters>%.10lf</DistanceMeters>\n", p->distance);

                // Now the optional metrics, if any...
                if ((pTrk->optTagCount != 0) && (pArgs->outMask != OM_NONE)) {
                    if (pArgs->outMask & OM_CADENCE) {
                        fprintf(pArgs->outFile, "            <Cadence>%d</Cadence>\n", p->cadence);
                    }
                    if (pArgs->outMask & OM_HR) {
                        fprintf(pArgs->outFile, "            <HeartRateBpm xsi:type=\"HeartRateInBeatsPerMinute_t\">\n");
                        fprintf(pArgs->outFile, "              <Value>%d</Value>\n", p->heartRate);
                        fprintf(pArgs->outFile, "            </HeartRateBpm>\n");
                    }
                    if (pArgs->outMask & OM_POWER) {
                        fprintf(pArgs->outFile, "            <Extensions>\n");
                        fprintf(pArgs->outFile, "              <TPX xmlns=\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\">\n");
                        fprintf(pArgs->outFile, "                <Watts>%d</Watts>\n", p->power);
                        fprintf(pArgs->outFile, "              </TPX>\n");
                        fprintf(pArgs->outFile, "            </Extensions>\n");
                    }
                }

                fprintf(pArgs->outFile, "          </Trackpoint>\n");

            }
        }
    }
    fprintf(pArgs->outFile, "        </Track>\n");
    fprintf(pArgs->outFile, "      </Lap>\n");
    fprintf(pArgs->outFile, "    </Activity\n");
    fprintf(pArgs->outFile, "  </Activities>\n");
    fprintf(pArgs->outFile, "</TrainingCenterDatabase>\n");
}

static void printOutput(GpsTrk *pTrk, CmdArgs *pArgs)
{
    if (pArgs->summary) {
        printSummary(pTrk, pArgs);
    } else if (pArgs->outFmt == csv) {
        printCsvFmt(pTrk, pArgs);
    } else if (pArgs->outFmt == gpx) {
        printGpxFmt(pTrk, pArgs);
    } else if (pArgs->outFmt == tcx) {
        printTcxFmt(pTrk, pArgs);
    }
}

int main(int argc, char **argv)
{
    CmdArgs cmdArgs = {0};
    GpsTrk gpsTrk = {0};
    TrkPt *pTrkPt;
    int n;

    // Parse the command arguments
    if ((n = parseArgs(argc, argv, &cmdArgs)) < 0) {
        return -1;
    }

    TAILQ_INIT(&gpsTrk.trkPtList);

    // Process each input file
    while (n < argc) {
        const char *fileSuffix;
        int s;
        cmdArgs.inFile = argv[n++];
        if ((fileSuffix = strrchr(cmdArgs.inFile, '.')) == NULL) {
            fprintf(stderr, "Unsupported input file %s\n", cmdArgs.inFile);
            return -1;
        }
        if (strcmp(fileSuffix, ".gpx") == 0) {
            s = parseGpxFile(&cmdArgs, &gpsTrk);
        } else if (strcmp(fileSuffix, ".tcx") == 0) {
            s = parseTcxFile(&cmdArgs, &gpsTrk);
        } else {
            fprintf(stderr, "Unsupported input file %s\n", cmdArgs.inFile);
            return -1;
        }
        if (s != 0) {
            fprintf(stderr, "Failed to parse input file %s\n", cmdArgs.inFile);
            return -1;
        }
        cmdArgs.inFile = NULL;
    }

    // Done reading all the TrkPt's!

    // The first point is used a the reference point...
    if ((pTrkPt = TAILQ_FIRST(&gpsTrk.trkPtList)) != NULL) {
        // Get the activity's start time
        gpsTrk.startTime = pTrkPt->time;

        if (pTrkPt->time == 0.0) {
            // TrkPt has no time information, likely because this
            // is a GPX route, not a GPX ride. In this case we need
            // to have a startTime and a setSpeed defined, in order
            // to be able to generate the timestamps that turn the
            // route into a ride (activity) ...
            if ((cmdArgs.startTime == 0) || (cmdArgs.setSpeed == 0.0)) {
                fprintf(stderr, "TrkPt %s:%u is missing time information and no startTime or setSpeed has been specified to turn a route into an activity!\n", pTrkPt->inFile, pTrkPt->lineNum);
                return -1;
            }

            // Set the timestamp of the first point to the desired
            // start time.
            pTrkPt->time = cmdArgs.startTime;
        } else if (cmdArgs.startTime != 0) {
            // We are changing the start date/time of the activity
            // so set the time offset used to adjust the timestamp
            // of each point accordingly.
            gpsTrk.timeOffset = cmdArgs.startTime - pTrkPt->time;
        }

        // If necessary, set the base time reference used to
        // generate relative timestamps in the CSV output data.
        if (cmdArgs.relTime) {
            gpsTrk.baseTime = pTrkPt->time;
        }

        // Get the activity's end time
        pTrkPt = TAILQ_LAST(&gpsTrk.trkPtList, TrkPtList);
        gpsTrk.endTime = pTrkPt->time;
    } else {
        fprintf(stderr, "No track points found!\n");
        return -1;
    }

    // At this point gpsTrk.trkPtList contains all the track
    // points from all the GPX input files...

    if (cmdArgs.closeGap) {
        // Close the time gap at the specified track
        // point.
        closeTimeGap(&gpsTrk, &cmdArgs);
    }

    // Compute the speed & grade data
    if (compDataPhase1(&gpsTrk, &cmdArgs) != 0) {
        fprintf(stderr, "Failed to compute speed/grade!\n");
        return -1;
    }

    // Do necessary adjustments
    compDataPhase2(&gpsTrk, &cmdArgs);

    // Generate the output data
    printOutput(&gpsTrk, &cmdArgs);

    if (cmdArgs.outFile != stdout) {
        fclose(cmdArgs.outFile);
    }

    return 0;
}


