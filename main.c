/*=========================================================================
 *
 *   Filename:           Makefile
 *
 *   Author:             Marcelo Mourier
 *   Created:            Fri Mar 12 09:56:32 PST 2021
 *
 *   Description:        This tool is used to process the activity metrics
 *                       in a GPX file.
 *
 *=========================================================================
 *
 *                  Copyright (c) 2021 Marcelo Mourier
 *
 *=========================================================================
*/

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/queue.h>
#include <time.h>

#define PROGRAM_VERSION     "0.4"

// Build info auto-generated by make
extern const char *buildInfo;

// Expected GPX file format:
//
//  <trk>
//    <name>My Epic Ride</name>
//    <type>cycling</type>
//    <trkseg>
//      <trkpt lat="44.3901710" lon="5.1954480">
//        <ele>323.9</ele>
//        <time>2021-02-19T22:54:09Z</time>
//        <extensions>
//          <power>25</power>
//          <gpxtpx:TrackPointExtension>
//            <gpxtpx:atemp>18</gpxtpx:atemp>
//            <gpxtpx:hr>109</gpxtpx:hr>
//            <gpxtpx:cad>65</gpxtpx:cad>
//          </gpxtpx:TrackPointExtension>
//        </extensions>
//     </trkpt>
//       .
//       .
//       .
//    </trkseg>
//  </trk>

typedef enum Bool {
    false = 0,
    true = 1
} Bool;

// A single GPS Track Point
typedef struct TrkPt {
    TAILQ_ENTRY(TrkPt)   tqEntry;   // node in the trkPtList
    int index;          // index in the trkPtList
    int lineNum;        // line number in the input file

    // GPS data from GPX file
    double latitude;    // in degrees decimal
    double longitude;   // in degrees decimal
    double elevation;   // in meters
    time_t time;        // in seconds since the Epoch

    // Sensor data from GPX file
    int ambTemp;        // in degrees Celsius
    int cadence;        // in rpm
    int heartRate;      // in bpm
    int power;          // in watts

    // Computed metrics
    Bool adjGrade;      // grade was adjusted
    time_t adjTime;     // adjusted timestamp
    time_t deltaT;      // time diff with previous point (in seconds)
    double deltaP;      // position diff (distance) with previous point (in meters)
    double deltaE;      // elevation diff with previous point (in meters)
    double run;         // horizontal distance from previous point (in meters)
    double distance;    // actual distance from the start (in meters)
    double speed;       // actual speed (in km/h)
    double grade;       // actual grade (in percentage)
} TrkPt;

// A GPS Track (sequence of Track Points)
typedef struct GpsTrk {
    // List of TrkPt's
    TAILQ_HEAD(TrkPtList, TrkPt) trkPtList;

    // Number of TrkPt's in trkPtList
    int numTrkPts;

    // Number of TrkPt's that had their elevation values
    // adjusted to match the min/max grade levels.
    int numElevAdj;

    // Base time
    time_t baseTime;                // time reference to generate relative timestamps

    // Aggregate values
    time_t time;
    time_t stoppedTime;             // amount of time with speed=0
    double distance;
    double elevGain;
    double elevLoss;

    // Min/Max values
    time_t maxDeltaT;
    double maxSpeed;
    double maxGrade;
    double minGrade;

    const TrkPt *maxTimeIntTrkPt;   // TrkPt with max time interval
    const TrkPt *maxSpeedTrkPt;     // TrkPt with max speed value
    const TrkPt *maxGradeTrkPt;     // TrkPt with max grade value
    const TrkPt *minGradeTrkPt;     // TrkPt with min grade value
} GpsTrk;

// Output file format
typedef enum OutFmt {
    nil = 0,
    csv = 1,    // Comma-Separated-Values format
    gpx = 2     // GPS Exchange format
} OutFmt;

// Output sensor data bit masks
#define OM_NONE     0x00    // no metrics
#define OM_ATEMP    0x01    // ambient temperature
#define OM_CADENCE  0x02    // cadence
#define OM_HR       0x04    // heart rate
#define OM_POWER    0x08    // power
#define OM_ALL      0x0f    // all metrics

typedef struct CmdArgs {
    int argc;           // number of arguments
    char **argv;        // list of arguments
    FILE *inFile;       // input file
    double maxGrade;    // max grade allowed (in %)
    double minGrade;    // min grade allowed (in %)
    double minSpeed;    // min speed below which we assume we are stopped
    const char *name;   // <name> tag
    FILE *outFile;      // output file
    OutFmt outFmt;      // format of the output data (csv, gpx)
    int outMask;        // bitmask of optional metrics to be included in the output
    Bool quiet;         // don't print any warning messages
    int rangeFrom;      // start point (inclusive)
    int rangeTo;        // end point (inclusive)
    Bool relTime;       // show relative timestamps
    Bool summary;       // show data summary
    int smaWindow;      // size of the moving average window
    Bool trim;          // trim points
} CmdArgs;

static const char *xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
static const char *gpxHeader = "<gpx creator=\"gpxFileTool version " PROGRAM_VERSION "\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\" version=\"1.1\" xmlns=\"http://www.topografix.com/GPX/1/1\">";
static const double degToRad = (double) 0.01745329252;  // decimal degrees to radians
static const double earthMeanRadius = (double) 6372797.560856;  // in meters

static const char *help =
        "SYNTAX:\n"
        "    gpxFileTool [OPTIONS]\n"
        "OPTIONS:\n"
        "    --help\n"
        "        Show this help and exit.\n"
        "    --input-file <name>\n"
        "        Read the input data from the specified file. If not specified\n"
        "        the input data is read from standard input.\n"
        "    --max-grade <value>\n"
        "        Limit the maximum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --min-grade <value>\n"
        "        Limit the minimum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --name <name>\n"
        "        String to use for the <name> tag of the track in the output\n"
        "        GPX file.\n"
        "    --sma-window <value>\n"
        "        Size of the window used to compute the Simple Moving Average\n"
        "        of the elevation values, in order to smooth them out.\n"
        "    --output-file <name>\n"
        "        Write the output data into the specified file. If not specified\n"
        "        the output data is written to standard output.\n"
        "    --output-filter <mask>\n"
        "        A bit mask that specifies the set of optional metrics to be\n"
        "        suppressed from the output:\n"
        "            0x01 - Ambient Temperature\n"
        "            0x02 - Cadence\n"
        "            0x04 - Heart Rate\n"
        "            0x08 - Power\n"
        "    --output-format {csv|gpx}\n"
        "        Specifies the format of the output data.\n"
        "    --quiet\n"
        "        Suppress all warning messages.\n"
        "    --range <a,b>\n"
        "        Limit the points to be processed to the range between point\n"
        "        'a' and point 'b', inclusive.\n"
        "    --rel-time\n"
        "        Show relative timestamps.\n"
        "    --remove-stops <speed>\n"
        "        Remove any points with a speed below the specified minimum\n"
        "        speed (in km/s), assuming we were actually stopped at the time.\n"
        "    --summary\n"
        "        Print only a summary of the activity metrics in human-readable\n"
        "        form and exit.\n"
        "    --trim\n"
        "        Trim all the points in the specified range. The timestamps of\n"
        "        the points after point 'b' are adjusted accordingly, to avoid\n"
        "        a discontinuity in the time sequence.\n"
        "    --version\n"
        "        Show version information and exit.";

static int parseArgs(int argc, char **argv, CmdArgs *pArgs)
{
    int numArgs, n;

    if (argc < 2) {
        fprintf(stderr, "Invalid syntax.  Use 'gpxFileTool --help' for more information.\n");
        return -1;
    }

    // By default include all optional metrics in the output
    pArgs->outMask = OM_ALL;

    for (n = 1, numArgs = argc -1; n <= numArgs; n++) {
        char *arg;

        arg = argv[n];

        if (strcmp(arg, "--help") == 0) {
            fprintf(stdout, "%s\n", help);
            exit(0);
        } else if (strcmp(arg, "--input-file") == 0) {
            const char *inputFile = argv[++n];
            if ((pArgs->inFile = fopen(inputFile, "r")) == NULL) {
                fprintf(stderr, "Can't open input file %s (%s)\n", inputFile, strerror(errno));
                return -1;
            }
        } else if (strcmp(arg, "--max-grade") == 0) {
            const char *maxGrade = argv[++n];
            if (sscanf(maxGrade, "%le", &pArgs->maxGrade) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, maxGrade);
                return -1;
            }
        } else if (strcmp(arg, "--min-grade") == 0) {
            const char *minGrade = argv[++n];
            if (sscanf(minGrade, "%le", &pArgs->minGrade) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, minGrade);
                return -1;
            }
        } else if (strcmp(arg, "--name") == 0) {
            const char *name = argv[++n];
            if ((pArgs->name = strdup(name)) == NULL) {
                fprintf(stderr, "Can't copy name argument: %s\n", name);
                return -1;
            }
        } else if (strcmp(arg, "--quiet") == 0) {
            pArgs->quiet = true;
        } else if (strcmp(arg, "--range") == 0) {
            const char *range = argv[++n];
            if (sscanf(range, "%d,%d", &pArgs->rangeFrom, &pArgs->rangeTo) != 2) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, range);
                return -1;
            }
            if ((pArgs->rangeFrom < 1) || (pArgs->rangeFrom >= pArgs->rangeTo)) {
                fprintf(stderr, "Invalid TrkPt range %d,%d\n", pArgs->rangeFrom, pArgs->rangeTo);
                return -1;
            }
        } else if (strcmp(arg, "--remove-stops") == 0) {
            const char *minSpeed = argv[++n];
            if (sscanf(minSpeed, "%le", &pArgs->minSpeed) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, minSpeed);
                return -1;
            }
        } else if (strcmp(arg, "--sma-window") == 0) {
            const char *smaWindow = argv[++n];
            if (sscanf(smaWindow, "%d", &pArgs->smaWindow) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, smaWindow);
                return -1;
            }
            pArgs->smaWindow += (pArgs->smaWindow % 2); // round up to an even value
        } else if (strcmp(arg, "--output-file") == 0) {
            const char *outputFile = argv[++n];
            if ((pArgs->outFile = fopen(outputFile, "w")) == NULL) {
                fprintf(stderr, "Can't open output file %s (%s)\n", outputFile, strerror(errno));
                return -1;
            }
        } else if (strcmp(arg, "--output-filter") == 0) {
            const char *outputFilter = argv[++n];
            int mask = 0;
            if (sscanf(outputFilter, "0x%x", &mask) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, outputFilter);
                return -1;
            }
            pArgs->outMask &= ~mask;
        } else if (strcmp(arg, "--output-format") == 0) {
            const char *outputFormat = argv[++n];
            if (strcmp(outputFormat, "csv") == 0) {
                pArgs->outFmt = csv;
            } else if (strcmp(outputFormat, "gpx") == 0) {
                pArgs->outFmt = gpx;
            } else {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, outputFormat);
                return -1;
            }
        } else if (strcmp(arg, "--rel-time") == 0) {
            pArgs->relTime = true;
        } else if (strcmp(arg, "--summary") == 0) {
            pArgs->summary = true;
            pArgs->relTime = true;  // force relative timestamps
        } else if (strcmp(arg, "--trim") == 0) {
            pArgs->trim = true;
        } else if (strcmp(arg, "--version") == 0) {
            fprintf(stdout, "Version %s %s\n", PROGRAM_VERSION, buildInfo);
            exit(0);
        } else {
            fprintf(stderr, "Invalid option: %s\n", arg);
            return -1;
        }
    }

    pArgs->argc = argc;
    pArgs->argv = argv;

    if (pArgs->inFile == NULL) {
        // By default read input from stdin
        pArgs->inFile = stdin;
    }

    if (pArgs->outFile == NULL) {
        // By default send output to stdout
        pArgs->outFile = stdout;
    }

    if (pArgs->outFmt == nil) {
        // By default use GPX output format
        pArgs->outFmt = gpx;
    }

    return 0;
}

// Parse the GPX file and create a list of Track Points
static GpsTrk *parseFile(CmdArgs *pArgs)
{
    GpsTrk *pTrk;
    TrkPt *pTrkPt = NULL;
    TrkPt *prevTrkPt = NULL;
    int index = 0;
    int trkPtNum = 0;
    int lineNum = 0;
    int metaData = 0;
    int trimTrkPts = false;
    time_t trimmedTime = 0;
    static char lineBuf[4096];

    // Check the input file type
    if ((fgets(lineBuf, sizeof(lineBuf), pArgs->inFile) == NULL) ||
        (strstr(lineBuf, "<?xml ") == NULL)) {
        fprintf(stderr, "Input file is not a valid GPX file !!!\n");
        return NULL;
    }
    lineNum += 1;

    // Create the GpsTrk object
    if ((pTrk = calloc(1, sizeof(GpsTrk))) == NULL) {
        fprintf(stderr, "Failed to alloc GpsTrk !!!\n");
        return NULL;
    }
    TAILQ_INIT(&pTrk->trkPtList);

    // Process one line at a time...
    while (fgets(lineBuf, sizeof(lineBuf), pArgs->inFile) != NULL) {
        double latitude, longitude, elevation;
        struct tm brkDwnTime = {0};
        int ambTemp, cadence, heartRate, power;

        lineNum++;

        //fprintf(stdout, "%u: %s", lineNum, lineBuf);

        // Ignore the metadata
        if (strstr(lineBuf, "<metadata>") != NULL) {
            metaData++;
            continue;
        } else if (strstr(lineBuf, "</metadata>") != NULL) {
            metaData--;
            continue;
        } else if (metaData) {
            continue;
        }

        if (sscanf(lineBuf, " <trkpt lat=\"%le\" lon=\"%le\">", &latitude, &longitude) == 2) {
            // New Track Point!
            if (pTrkPt != NULL) {
                // Hu?
                fprintf(stderr, "SPONG! Nested <trkpt> block !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Update absolute TrkPt index. This index increases
            // monotonically, even for TrkPts that are trimmed out.
            index++;

            if ((pTrkPt = calloc(1, sizeof(TrkPt))) == NULL) {
                fprintf(stderr, "Failed to alloc TrkPt !!!\n");
                return NULL;
            }

            pTrkPt->lineNum = lineNum;
            pTrkPt->latitude = latitude;
            pTrkPt->longitude = longitude;
        } else if (sscanf(lineBuf, " <ele>%le</ele>", &elevation) == 1) {
            // Got the elevation!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->elevation = elevation;
        } else if (strptime(lineBuf, " <time>%Y-%m-%dT%H:%M:%S", &brkDwnTime) != NULL) {
            // Got the time!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Convert to seconds since the Epoch
            if ((pTrkPt->time = mktime(&brkDwnTime)) == (time_t) -1) {
                fprintf(stderr, "Failed to make time value\n");
                return NULL;
            }
        } else if (sscanf(lineBuf, " <power>%d</power>", &power) == 1) {
            // Got the power!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->power = power;
        } else if (sscanf(lineBuf, " <gpxtpx:atemp>%d</gpxtpx:atemp>", &ambTemp) == 1) {
            // Got the ambient temperature!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->ambTemp = ambTemp;
        } else if (sscanf(lineBuf, " <gpxtpx:cad>%d</gpxtpx:cad>", &cadence) == 1) {
            // Got the cadence!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->cadence = cadence;
        } else if (sscanf(lineBuf, " <gpxtpx:hr>%d</gpxtpx:hr>", &heartRate) == 1) {
            // Got the heart rate!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->heartRate = heartRate;
        } else if (strstr(lineBuf, "</trkpt>") != NULL) {
            // End of Track Point!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> block !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Let's do some consistency checks...

            if (pTrkPt->elevation == 0) {
                fprintf(stderr, "TrkPt at line #%u is missing its elevation data!\n", pTrkPt->lineNum);
                return NULL;
            }
            if (pTrkPt->time == 0) {
                fprintf(stderr, "TrkPt at line #%u is missing its time data!\n", pTrkPt->lineNum);
                return NULL;
            }
            if ((prevTrkPt != NULL) && (prevTrkPt->time == pTrkPt->time)) {
                if (!pArgs->quiet) {
                    fprintf(stderr, "WARNING: TrkPt at line #%u has the same timestamp as the previous point at line #%u!\n",
                            pTrkPt->lineNum, prevTrkPt->lineNum);
                }
            }

            // Sometimes when multiple GPX files are stitched together
            // the timestamps can go backwards in time!
            if ((prevTrkPt != NULL) && (pTrkPt->time < prevTrkPt->time)) {
                fprintf(stderr, "TrkPt at line #%u has a timestamp *BEFORE* the previous point at line #%u!\n",
                        pTrkPt->lineNum, prevTrkPt->lineNum);
                return NULL;
            }

            //fprintf(stdout, "line#=%u lat=%.16lf lon=%.16lf ele=%.16lf time=%ld power=%d cadence=%d\n",
            //        pTrkPt->lineNum, pTrkPt->latitude, pTrkPt->longitude, pTrkPt->elevation, pTrkPt->time, pTrkPt->power, pTrkPt->cadence);

            // Do we need to trim this TrkPt?
            if (pArgs->trim) {
                if (index == pArgs->rangeFrom) {
                    trimTrkPts = true; // start trimming
                    trimmedTime = pTrkPt->time;  // set baseline time
                    free(pTrkPt);
                    pTrkPt = NULL;
                    continue;
                } else if (index == pArgs->rangeTo) {
                    trimTrkPts = false; // stop trimming
                    trimmedTime = pTrkPt->time - trimmedTime + 1;    // total time trimmed
                    free(pTrkPt);
                    pTrkPt = NULL;
                    continue;
                } else if (trimTrkPts) {
                    free(pTrkPt);
                    pTrkPt = NULL;
                    continue;
                }
            }

            // This TrkPt has been "accepted" !

            pTrkPt->index = ++trkPtNum;

            if (trimmedTime) {
                // If we trimmed out some points, move the timestamp
                // back in time to avoid a discontinuity in the time
                // sequence.
                pTrkPt->time -= trimmedTime;
            }

            // If necessary, set the base time reference
            if (pArgs->relTime && (pTrk->baseTime == 0)) {
                pTrk->baseTime = pTrkPt->time;
            }

            // Insert track point at the tail of the queue and update
            // the TrkPt count.
            TAILQ_INSERT_TAIL(&pTrk->trkPtList, pTrkPt, tqEntry);
            pTrk->numTrkPts++;

            prevTrkPt = pTrkPt;
            pTrkPt = NULL;
        } else {
            // Ignore this line...
        }
    }

#if 0
    if (trkPtNum) {
        fprintf(stdout, "Processed %d track points...\n", trkPtNum);
    } else {
        fprintf(stdout, "No track points found!\n");
    }
#endif

    return pTrk;
}

// Compute the distance (in meters) between two track points
// using the Haversine formula. See:
//   https://en.wikipedia.org/wiki/Haversine_formula
static double compDistance(const TrkPt *p1, const TrkPt *p2)
{
    double latitude1 = p1->latitude * degToRad; // p1's latitude in radians
    double latitude2 = p2->latitude * degToRad; // p2's latitude in radians
    double latDiff = (p2->latitude - p1->latitude) * degToRad; // latitude diff in radians
    double lonDiff = (p2->longitude - p1->longitude) * degToRad; // longitude diff in radians
    double a;
    double c;

    a = pow(sin(latDiff/2), 2) + cos(latitude1) * cos(latitude2) * pow(sin(lonDiff/2), 2);
    assert(a <= 1.0);
    c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));

    return (c * earthMeanRadius);
}

// Compute the SMA of the grade value of the given point.
// The SMA uses a window size of N points, where N is an even
// value. The average is computed using the N/2 values before
// the point, the value of the point, and the N/2 values after
// the point, for a total of N+1 points:
//
//   <-- N/2 --> <-- N/2 -->
//   +----------+----------+
//              p
//
static void compGradeSma(GpsTrk *pTrk, TrkPt *p, int smaWindow)
{
    int i;
    int n = smaWindow / 2;
    int numPoints = 1;
    double gradeSum = p->grade;
    TrkPt *tp;

    // Points before the given point
    for (i = 0, tp = TAILQ_PREV(p, TrkPtList, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_PREV(tp, TrkPtList, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Points after the given point
    for (i = 0, tp = TAILQ_NEXT(p, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_NEXT(tp, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Override the original grade value with the
    // computed SMA value.
    p->grade = gradeSum / numPoints;

    // Flag that this point had its grade adjusted
    p->adjGrade = true;
}

static int pointWithinRange(const CmdArgs *pArgs, const TrkPt *p)
{
    if (pArgs->rangeFrom == 0) {
        // No actual range specified, so all points
        // are within range...
        return true;
    }

    if ((p->index >= pArgs->rangeFrom) && (p->index <= pArgs->rangeTo)) {
        // Point is within specified range
        return true;
    }

    return false;
}

static void adjMaxGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt at line #%u has a grade of %.2lf%% that exceeds the max value %.2lf%% !\n",
                p2->lineNum, p2->grade, pArgs->maxGrade);
    }

    // Override original value with the max value
    p2->grade = pArgs->maxGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static void adjMinGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt at line #%u has a grade of %.2lf%% that exceeds the min value %.2lf%% !\n",
                p2->lineNum, p2->grade, pArgs->minGrade);

    }

    // Override original value with the min value
    p2->grade = pArgs->minGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static int compDataPhase1(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = NULL;   // previous TrkPt
    TrkPt *p2 = NULL;   // current TrkPt

    // Compute the distance, elevation diff, speed, and grade
    // between each pair of points...
    TAILQ_FOREACH(p2, &pTrk->trkPtList, tqEntry) {
        Bool stopped = false;

        if (p1 != NULL) {
            // Compute the position difference (distance) between
            // the two points.
            p2->deltaP = compDistance(p1, p2);

            // Compute the time interval between the two points.
            // Ideally fixed at 1-sec, but some GPS devices (e.g.
            // Garmin Edge) may use a "smart" recording mode that
            // can have several seconds between points...
            if ((p2->deltaT = p2->time - p1->time) == 0) {
                p2->deltaT = 1; // Hu? Assume a 1-sec interval
            }

            // Compute the speed as "distance over time" and
            // convert it to km/h.
            p2->speed = (p2->deltaP / (double) p2->deltaT) * 3.6;

            // Are we stopped?
            if (p2->speed == 0.0) {
                stopped = true;
            } else if ((pArgs->minSpeed != 0.0) && (p2->speed < pArgs->minSpeed)) {
                // The speed is below the specified minimum value
                // so assume we are stopped.
                if (!pArgs->quiet) {
                    fprintf(stderr, "WARNING: TrkPt at line #%u has a speed value %.10lf km/h below the minimum value %.10lf km/h !\n",
                            p2->lineNum, p2->speed, pArgs->minSpeed);
                }

                stopped = true;
            } else {
                stopped = false;
            }

            if (stopped) {
                if (!pArgs->quiet) {
                    fprintf(stderr, "WARNING: Stopped! (line #%u, speed %.10lf km/h, deltaT %ld, stoppedTime %ld\n",
                            p2->lineNum, p2->speed, p2->deltaT, pTrk->stoppedTime);
                }

                // Update the stopped time value for the activity
                pTrk->stoppedTime += p2->deltaT;

                // Set the speed to zero, to indicate we were not
                // moving, and skip this point when we generate
                // the output data.
                p2->speed = 0;
            } else {
                // Adjust the timestamp to remove any stopped time
                p2->adjTime = p2->time - pTrk->stoppedTime;

                // Update the total distance for the activity
                pTrk->distance += p2->deltaP;

                // Set the distance (from the start) of this
                // point.
                p2->distance = pTrk->distance;

                // Update the total time for the activity
                pTrk->time += p2->deltaT;

                // Update the max time interval between two points
                if (p2->deltaT > pTrk->maxDeltaT) {
                    pTrk->maxDeltaT = p2->deltaT;
                    pTrk->maxTimeIntTrkPt = p2;
                }

                // Now let's compute the grade!
                {
                    double rise;

                    // Elevation difference (can be negative)
                    p2->deltaE = p2->elevation - p1->elevation;

                    // The rise is always positive!
                    rise = fabs(p2->deltaE);

                    if (p2->deltaP > rise) {
                        // Use Pythagoras's Theorem to compute the horizontal
                        // distance (run) based on the distance (hypotenuse)
                        // and the elevation difference (rise). Notice that
                        // the rise value inherits whatever error the elevation
                        // value may have...
                        //
                        //                 p2 +
                        //                   /|
                        //                  / |
                        //                 /  |
                        //       distance /   | rise
                        //               /    |
                        //              /     |
                        //             /      |
                        //         p1 +-------+
                        //               run
                        //
                        //    run^2 + rise^2 = distance^2
                        //
                        double distance = p2->deltaP;
                        double runSquare = (distance * distance) - (rise * rise);
                        if (runSquare > 0.0) {
                            p2->run = sqrt(runSquare);
                        } else {
                            // Hu? This should not happen!
                            fprintf(stderr, "SPONG! TrkPt at line #%u has a negative runSquare value ! (distance=%.10lf rise=%.10lf runSquare=%.10lf)\n",
                                    p2->lineNum, distance, rise, runSquare);
                            return -1;
                        }

                        if (p2->run != 0.0) {
                            // Compute the grade as "rise over run". Here we use deltaE
                            // instead of rise, so that the grade value has the right
                            // sign...
                            p2->grade = (p2->deltaE * 100.0) / p2->run;  // in [%]
                        } else {
                            // Hu? This should not happen!
                            if (!pArgs->quiet) {
                                fprintf(stderr, "WARNING: TrkPt at line #%u has a null run value !\n",
                                        p2->lineNum);
                            }

                            // Use the values from the previous point
                            p2->elevation = p1->elevation;
                            p2->speed = p1->speed;
                            p2->grade = p1->grade;
                        }
                    } else {
                        // This is likely the product of bad GPS data. Just use
                        // the data from the previous point...
                        if (!pArgs->quiet) {
                            fprintf(stderr, "WARNING: TrkPts at lines #%u and #%u have inconsistent distance (%.10lf) and rise (%.10lf) values ! (speed=%.10lf)\n",
                                    p2->lineNum, p1->lineNum, p2->deltaP, rise, p2->speed);
                        }
                        p2->elevation = p1->elevation;
                        p2->speed = p1->speed;
                        p2->grade = p1->grade;
                    }
                }
            }
        }

        p1 = p2;
    }

    return 0;
}

static void adjElevation(GpsTrk *pTrk, TrkPt *p1, TrkPt *p2)
{
    double grade = (p2->grade / 100.0); // in decimal (0.00 .. 1.00)
    double grade2 = (grade * grade);    // grade squared
    double deltaP2 = (p2->deltaP * p2->deltaP); // deltaP squared
    double rise = sqrt((grade2 * deltaP2) / (1.0 + grade2));
    double adjElev;

    if (p2->deltaE >= 0.0) {
        p2->deltaE = rise;
    } else {
        p2->deltaE = -rise;
    }
    adjElev = p1->elevation + p2->deltaE;
    if (adjElev != p2->elevation) {
        p2->elevation = adjElev;
        pTrk->numElevAdj++;
    }
}

static int compDataPhase2(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = NULL;   // previous TrkPt
    TrkPt *p2 = NULL;   // current TrkPt

    TAILQ_FOREACH(p2, &pTrk->trkPtList, tqEntry) {
        if (p1 != NULL) {
            // Skip points where we were stopped
            if (p2->speed != 0.0) {
                if (pArgs->smaWindow != 0) {
                    // Compute the SMA of the grade value
                    compGradeSma(pTrk, p2, pArgs->smaWindow);
                }

                // See if we need to limit the max grade values
                if ((pArgs->maxGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade > pArgs->maxGrade)) {
                    adjMaxGrade(pTrk, pArgs, p1, p2);
                }

                // See if we need to limit the min grade values
                if ((pArgs->minGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade < pArgs->minGrade)) {
                    adjMinGrade(pTrk, pArgs, p1, p2);
                }

                // If necessary, correct the elevation value based
                // on the adjusted grade value. We need to adjust
                // the value of delatE, while the value of deltaP
                // remains invariant; i.e. the deltaP vector needs
                // to rotate along an arc so that its angle results
                // in the adjusted grade value.
                //
                // deltaE^2 = (grade^2 x deltaP^2) / (1 + grade^2)
                //
                if (p2->adjGrade) {
                    adjElevation(pTrk, p1, p2);
                }

                // Update the rolling elevation gain/loss values
                if (p2->deltaE >= 0) {
                    pTrk->elevGain += p2->deltaE;
                } else {
                    pTrk->elevLoss -= p2->deltaE;
                }

                // Update the min/max values
                if (p2->speed > pTrk->maxSpeed) {
                     pTrk->maxSpeed = p2->speed;
                     pTrk->maxSpeedTrkPt = p2;
                }
                if (p2->grade > pTrk->maxGrade) {
                     pTrk->maxGrade = p2->grade;
                     pTrk->maxGradeTrkPt = p2;
                } else if (p2->grade < pTrk->minGrade) {
                    pTrk->minGrade = p2->grade;
                    pTrk->minGradeTrkPt = p2;
                }
            }
        }

        p1 = p2;
    }

    return 0;
}

static void printSummary(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t movingTime;
    time_t hr, min, sec;
    const TrkPt *p;

    fprintf(pArgs->outFile, "  numTrkPts: %d\n", pTrk->numTrkPts);

    hr = pTrk->time / 3600;
    min = (pTrk->time - (hr * 3600)) / 60;
    sec = (pTrk->time - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, "       time: %02ld:%02ld:%02ld\n", hr, min, sec);

    movingTime = pTrk->time - pTrk->stoppedTime;
    hr = movingTime / 3600;
    min = (movingTime - (hr * 3600)) / 60;
    sec = (movingTime - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, " movingTime: %02ld:%02ld:%02ld\n", hr, min, sec);

    hr = pTrk->stoppedTime / 3600;
    min = (pTrk->stoppedTime - (hr * 3600)) / 60;
    sec = (pTrk->stoppedTime - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, "stoppedTime: %02ld:%02ld:%02ld\n", hr, min, sec);

    fprintf(pArgs->outFile, " numElevAdj: %d\n", pTrk->numElevAdj);

    fprintf(pArgs->outFile, "   distance: %.10lf km\n", (pTrk->distance / 1000.0));
    fprintf(pArgs->outFile, "   elevGain: %.10lf m\n", pTrk->elevGain);
    fprintf(pArgs->outFile, "   elevLoss: %.10lf m\n", pTrk->elevLoss);
    if ((p = pTrk->maxTimeIntTrkPt) != NULL) {
        fprintf(pArgs->outFile, "  maxDeltaT: %ld sec at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxDeltaT, p->index, p->lineNum, (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxSpeedTrkPt) != NULL) {
        fprintf(pArgs->outFile, "   maxSpeed: %.10lf km/h at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxSpeed, p->index, p->lineNum, (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "   maxGrade: %.2lf%% at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxGrade, p->index, p->lineNum, (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->minGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "   minGrade: %.2lf%% at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->minGrade, p->index, p->lineNum, (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
}

static void printCsvFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p;

    // Print column banner line
    fprintf(pArgs->outFile, "<line#>,<trkpt>,<time>,<lat>,<lon>,<ele>,");
    fprintf(pArgs->outFile, "<power>,<atemp>,<cadence>,<hr>,<deltaP>,<deltaT>,<deltaE>,run,<distance>,<speed>,<grade>\n");


    TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
        // Skip points where we were stopped
        if (p->speed != 0.0) {
            fprintf(pArgs->outFile, "%d,%d,%ld,%.10lf,%.10lf,%.10lf,",
                    p->lineNum,                     // <line#>
                    p->index,                       // <trkPt>
                    (p->time - pTrk->baseTime),     // <time>
                    p->latitude,                    // <lat>
                    p->longitude,                   // <lon>
                    p->elevation);                  // <ele>
            fprintf(pArgs->outFile, "%d,%d,%d,%d,%.10lf,%ld,%.10lf,%.10lf,%.10lf,%.10lf,%.2lf\n",
                    p->power,                       // <power>
                    p->ambTemp,                     // <atemp>
                    p->cadence,                     // <cadence>
                    p->heartRate,                   // <hr>
                    p->deltaP,                      // <deltaP>
                    p->deltaT,                      // <deltaT>
                    p->deltaE,                      // <deltaE>
                    p->run,                         // <run>
                    (p->distance / 1000.0),         // <distance>
                    p->speed,                       // <speed>
                    p->grade);                      // <grade>
        }
    }
}

static void printGpxFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t now;
    struct tm brkDwnTime = {0};
    char timeBuf[128];

    // Print headers
    fprintf(pArgs->outFile, "%s\n", xmlHeader);
    fprintf(pArgs->outFile, "%s\n", gpxHeader);

    // Print metadata. For the <desc> tag use the
    // list of arguments used by the tool...
    now = time(NULL);
    strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&now, &brkDwnTime));
    fprintf(pArgs->outFile, "  <metadata>\n");
    fprintf(pArgs->outFile, "    <desc>GPX input file processed by: ");
    for (int n = 0; n < pArgs->argc; n++) {
        fprintf(pArgs->outFile, "%s ", pArgs->argv[n]);
    }
    fprintf(pArgs->outFile, "    </desc>\n");
    fprintf(pArgs->outFile, "    <time>%s</time>\n", timeBuf);
    fprintf(pArgs->outFile, "  </metadata>\n");

    // Print track
    fprintf(pArgs->outFile, "  <trk>\n");
    if (pArgs->name != NULL) {
        fprintf(pArgs->outFile, "    <name>%s</name>\n", pArgs->name);
    }

    // Print track segment
    fprintf(pArgs->outFile, "    <trkseg>\n");
    {
        TrkPt *p;

        // Print all the track points
        TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
            // Skip points where we were stopped
            if (p->speed != 0.0) {
                time_t timeStamp = (p->adjTime != 0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
                strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&timeStamp, &brkDwnTime));
                fprintf(pArgs->outFile, "      <trkpt lat=\"%.10lf\" lon=\"%.10lf\">\n", p->latitude, p->longitude);
                fprintf(pArgs->outFile, "        <ele>%.10lf</ele>\n", p->elevation);
                fprintf(pArgs->outFile, "        <time>%sZ</time>\n", timeBuf);

                // Now the optional metrics
                if (pArgs->outMask != OM_NONE) {
                    fprintf(pArgs->outFile, "        <extensions>\n");
                    if (pArgs->outMask & OM_POWER) {
                        fprintf(pArgs->outFile, "          <power>%d</power>\n", p->power);
                    }
                    if (pArgs->outMask & (OM_ATEMP | OM_CADENCE | OM_HR)) {
                        fprintf(pArgs->outFile, "          <gpxtpx:TrackPointExtension>\n");
                        //            <gpxtpx:atemp>18</gpxtpx:atemp>
                        //            <gpxtpx:hr>109</gpxtpx:hr>
                        //            <gpxtpx:cad>65</gpxtpx:cad>
                        if (pArgs->outMask & OM_ATEMP) {
                            fprintf(pArgs->outFile, "            <gpxtpx:atemp>%d</gpxtpx:atemp>\n", p->ambTemp);
                        }
                        if (pArgs->outMask & OM_CADENCE) {
                            fprintf(pArgs->outFile, "            <gpxtpx:cad>%d</gpxtpx:cad>\n", p->cadence);
                        }
                        if (pArgs->outMask & OM_HR) {
                            fprintf(pArgs->outFile, "            <gpxtpx:hr>%d</gpxtpx:hr>\n", p->heartRate);
                        }
                        fprintf(pArgs->outFile, "          </gpxtpx:TrackPointExtension>\n");
                    }
                    fprintf(pArgs->outFile, "        </extensions>\n");
                }

                fprintf(pArgs->outFile, "      </trkpt>\n");
            }
        }
    }
    fprintf(pArgs->outFile, "    </trkseg>\n");

    fprintf(pArgs->outFile, "  </trk>\n");

    fprintf(pArgs->outFile, "</gpx>\n");
}

static int printOutput(GpsTrk *pTrk, CmdArgs *pArgs)
{
    if (pArgs->summary) {
        printSummary(pTrk, pArgs);
    } else if (pArgs->outFmt == csv) {
        printCsvFmt(pTrk, pArgs);
    } else if (pArgs->outFmt == gpx) {
        printGpxFmt(pTrk, pArgs);
    }

    return 0;
}

static void cleanup(CmdArgs *pArgs, GpsTrk *pTrk)
{
    fclose(pArgs->inFile);
    if (pArgs->outFile != stdout)
        fclose(pArgs->outFile);

    if (pTrk != NULL) {
        TrkPt *p;
        while ((p = TAILQ_FIRST(&pTrk->trkPtList)) != NULL) {
            TAILQ_REMOVE(&pTrk->trkPtList, p, tqEntry);
            free(p);
        }

        free(pTrk);
    }
}

int main(int argc, char **argv)
{
    CmdArgs cmdArgs = {0};
    GpsTrk *pTrk;
    int s = 0;

    // Parse the command arguments
    if (parseArgs(argc, argv, &cmdArgs) != 0) {
        return -1;
    }

    // Parse the GPX input data
    if ((pTrk = parseFile(&cmdArgs)) != NULL) {
        // Compute the speed & grade data
        if (compDataPhase1(pTrk, &cmdArgs) == 0) {
            // Do necessary adjustments
            compDataPhase2(pTrk, &cmdArgs);
        }

        // Generate the output data
        printOutput(pTrk, &cmdArgs);
    } else {
        fprintf(stderr, "Failed to parse input file\n");
        s = -1;
    }

    cleanup(&cmdArgs, pTrk);

    return s;
}


