/*=========================================================================
 *
 *   Filename:           Makefile
 *
 *   Author:             Marcelo Mourier
 *   Created:            Fri Mar 12 09:56:32 PST 2021
 *
 *   Description:        This tool is used to process the activity metrics
 *                       in a GPX file.
 *
 *=========================================================================
 *
 *                  Copyright (c) 2021 Marcelo Mourier
 *
 *=========================================================================
*/

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/queue.h>
#include <time.h>

#define PROGRAM_VERSION     "0.4"

// Build info auto-generated by make
extern const char *buildInfo;

// Expected GPX file format:
//
//  <trk>
//    <name>My Epic Ride</name>
//    <type>cycling</type>
//    <trkseg>
//      <trkpt lat="44.3901710" lon="5.1954480">
//        <ele>323.9</ele>
//        <time>2021-02-19T22:54:09Z</time>
//        <extensions>
//          <power>25</power>
//          <gpxtpx:TrackPointExtension>
//            <gpxtpx:atemp>18</gpxtpx:atemp>
//            <gpxtpx:hr>109</gpxtpx:hr>
//            <gpxtpx:cad>65</gpxtpx:cad>
//          </gpxtpx:TrackPointExtension>
//        </extensions>
//     </trkpt>
//       .
//       .
//       .
//    </trkseg>
//  </trk>

typedef enum Bool {
    false = 0,
    true = 1
} Bool;

// A single GPS Track Point
typedef struct TrkPt {
    TAILQ_ENTRY(TrkPt)   tqEntry;   // node in the trkPtList
    int index;          // index in the trkPtList
    int lineNum;        // line number in the input file

    // GPS data from GPX file
    double latitude;    // in degrees decimal
    double longitude;   // in degrees decimal
    double elevation;   // in meters
    double time;        // in seconds+millisec since the Epoch

    // Sensor data from GPX file
    int ambTemp;        // in degrees Celsius
    int cadence;        // in rpm
    int heartRate;      // in bpm
    int power;          // in watts

    // Computed metrics
    Bool adjGrade;      // grade was adjusted
    double adjTime;     // adjusted timestamp
    double deltaT;      // time diff with previous point (in seconds)
    double deltaP;      // position diff (distance) with previous point (in meters)
    double deltaE;      // elevation diff with previous point (in meters)
    double run;         // horizontal distance from previous point (in meters)
    double distance;    // actual distance from the start (in meters)
    double speed;       // actual speed (in km/h)
    double grade;       // actual grade (in percentage)
} TrkPt;

// A GPS Track (sequence of Track Points)
typedef struct GpsTrk {
    // List of TrkPt's
    TAILQ_HEAD(TrkPtList, TrkPt) trkPtList;

    // Number of TrkPt's in trkPtList
    int numTrkPts;

    // Number of TrkPt's that had their elevation values
    // adjusted to match the min/max grade levels.
    int numElevAdj;

    // Number of TrkPt's discarded because they were a
    // duplicate of the previous point
    int numDupTrkPts;

    // Number of TrkPt's trimmed out
    int numTrimTrkPts;

    // Number of optional sensor tags
    int optTagCount;

    // Base time
    double baseTime;                // time reference to generate relative timestamps

    // Time offset
    double timeOffset;              // to set/change the activity's start time

    // Aggregate values
    double time;
    double stoppedTime;             // amount of time with speed=0
    double distance;
    double elevGain;
    double elevLoss;

    // Min/Max values
    double maxDeltaT;
    double maxSpeed;
    double maxGrade;
    double minGrade;

    const TrkPt *maxTimeIntTrkPt;   // TrkPt with max time interval
    const TrkPt *maxSpeedTrkPt;     // TrkPt with max speed value
    const TrkPt *maxGradeTrkPt;     // TrkPt with max grade value
    const TrkPt *minGradeTrkPt;     // TrkPt with min grade value
} GpsTrk;

// Output file format
typedef enum OutFmt {
    nil = 0,
    csv = 1,    // Comma-Separated-Values format
    gpx = 2     // GPS Exchange format
} OutFmt;

// Output sensor data bit masks
#define OM_NONE     0x00    // no metrics
#define OM_ATEMP    0x01    // ambient temperature
#define OM_CADENCE  0x02    // cadence
#define OM_HR       0x04    // heart rate
#define OM_POWER    0x08    // power
#define OM_ALL      0x0f    // all metrics

typedef struct CmdArgs {
    int argc;           // number of arguments
    char **argv;        // list of arguments
    FILE *inFile;       // input file
    double maxGrade;    // max grade allowed (in %)
    double minGrade;    // min grade allowed (in %)
    double minSpeed;    // min speed below which we assume we are stopped
    const char *name;   // <name> tag
    FILE *outFile;      // output file
    OutFmt outFmt;      // format of the output data (csv, gpx)
    int outMask;        // bitmask of optional metrics to be included in the output
    Bool quiet;         // don't print any warning messages
    int rangeFrom;      // start point (inclusive)
    int rangeTo;        // end point (inclusive)
    Bool relTime;       // show relative timestamps
    double setSpeed;    // speed to use to generate timestamps (in m/s)
    int smaWindow;      // size of the moving average window
    double startTime;   // start time for the activity
    Bool summary;       // show data summary
    Bool trim;          // trim points
    int type;           // activity type
} CmdArgs;

static const char *xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
static const char *gpxHeader = "<gpx creator=\"gpxFileTool version " PROGRAM_VERSION "\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\" version=\"1.1\" xmlns=\"http://www.topografix.com/GPX/1/1\">";
static const double degToRad = (double) 0.01745329252;  // decimal degrees to radians
static const double earthMeanRadius = (double) 6372797.560856;  // in meters

static const char *help =
        "SYNTAX:\n"
        "    gpxFileTool [OPTIONS]\n"
        "OPTIONS:\n"
        "    --help\n"
        "        Show this help and exit.\n"
        "    --input-file <name>\n"
        "        Read the input data from the specified file. If not specified\n"
        "        the input data is read from standard input.\n"
        "    --max-grade <value>\n"
        "        Limit the maximum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --min-grade <value>\n"
        "        Limit the minimum grade to the specified value. The elevation\n"
        "        values are adjusted accordingly.\n"
        "    --name <name>\n"
        "        String to use for the <name> tag of the track in the output\n"
        "        GPX file.\n"
        "    --output-file <name>\n"
        "        Write the output data into the specified file. If not specified\n"
        "        the output data is written to standard output.\n"
        "    --output-filter <mask>\n"
        "        A bit mask that specifies the set of optional metrics to be\n"
        "        suppressed from the output:\n"
        "            0x01 - Ambient Temperature\n"
        "            0x02 - Cadence\n"
        "            0x04 - Heart Rate\n"
        "            0x08 - Power\n"
        "    --output-format {csv|gpx}\n"
        "        Specifies the format of the output data.\n"
        "    --quiet\n"
        "        Suppress all warning messages.\n"
        "    --range <a,b>\n"
        "        Limit the points to be processed to the range between point\n"
        "        'a' and point 'b', inclusive.\n"
        "    --rel-time\n"
        "        Use relative timestamps in the CSV output.\n"
        "    --remove-stops <speed>\n"
        "        Remove any points with a speed below the specified minimum\n"
        "        speed (in km/s), assuming we were actually stopped at the time.\n"
        "    --set-speed <speed>\n"
        "        Use the specified speed value (in km/h) to generate missing\n"
        "        timestamps in the input GPX file.\n"
        "    --sma-window <value>\n"
        "        Size of the window used to compute the Simple Moving Average\n"
        "        of the elevation values, in order to smooth them out. It must be\n"
        "        an odd value."
        "    --start-time <time>\n"
        "        Start time for the activity (in UTC time). The timestamp of each\n"
        "        point is adjusted accordingly. Format is: 2018-01-22T10:01:10Z.\n"
        "    --summary\n"
        "        Print only a summary of the activity metrics in human-readable\n"
        "        form and exit.\n"
        "    --trim\n"
        "        Trim all the points in the specified range. The timestamps of\n"
        "        the points after point 'b' are adjusted accordingly, to avoid\n"
        "        a discontinuity in the time sequence.\n"
        "    --version\n"
        "        Show version information and exit.";

static int parseArgs(int argc, char **argv, CmdArgs *pArgs)
{
    int numArgs, n;

    if (argc < 2) {
        fprintf(stderr, "Invalid syntax.  Use 'gpxFileTool --help' for more information.\n");
        return -1;
    }

    // By default include all optional metrics in the output
    pArgs->outMask = OM_ALL;

    for (n = 1, numArgs = argc -1; n <= numArgs; n++) {
        char *arg;

        arg = argv[n];

        if (strcmp(arg, "--help") == 0) {
            fprintf(stdout, "%s\n", help);
            exit(0);
        } else if (strcmp(arg, "--input-file") == 0) {
            const char *inputFile = argv[++n];
            if ((pArgs->inFile = fopen(inputFile, "r")) == NULL) {
                fprintf(stderr, "Can't open input file %s (%s)\n", inputFile, strerror(errno));
                return -1;
            }
        } else if (strcmp(arg, "--max-grade") == 0) {
            const char *maxGrade = argv[++n];
            if (sscanf(maxGrade, "%le", &pArgs->maxGrade) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, maxGrade);
                return -1;
            }
        } else if (strcmp(arg, "--min-grade") == 0) {
            const char *minGrade = argv[++n];
            if (sscanf(minGrade, "%le", &pArgs->minGrade) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, minGrade);
                return -1;
            }
        } else if (strcmp(arg, "--name") == 0) {
            const char *name = argv[++n];
            if ((pArgs->name = strdup(name)) == NULL) {
                fprintf(stderr, "Can't copy name argument: %s\n", name);
                return -1;
            }
        } else if (strcmp(arg, "--quiet") == 0) {
            pArgs->quiet = true;
        } else if (strcmp(arg, "--range") == 0) {
            const char *range = argv[++n];
            if (sscanf(range, "%d,%d", &pArgs->rangeFrom, &pArgs->rangeTo) != 2) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, range);
                return -1;
            }
            if ((pArgs->rangeFrom < 1) || (pArgs->rangeFrom >= pArgs->rangeTo)) {
                fprintf(stderr, "Invalid TrkPt range %d,%d\n", pArgs->rangeFrom, pArgs->rangeTo);
                return -1;
            }
        } else if (strcmp(arg, "--remove-stops") == 0) {
            const char *minSpeed = argv[++n];
            if (sscanf(minSpeed, "%le", &pArgs->minSpeed) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, minSpeed);
                return -1;
            }
        } else if (strcmp(arg, "--output-file") == 0) {
            const char *outputFile = argv[++n];
            if ((pArgs->outFile = fopen(outputFile, "w")) == NULL) {
                fprintf(stderr, "Can't open output file %s (%s)\n", outputFile, strerror(errno));
                return -1;
            }
        } else if (strcmp(arg, "--output-filter") == 0) {
            const char *outputFilter = argv[++n];
            int mask = 0;
            if (sscanf(outputFilter, "0x%x", &mask) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, outputFilter);
                return -1;
            }
            pArgs->outMask &= ~mask;
        } else if (strcmp(arg, "--output-format") == 0) {
            const char *outputFormat = argv[++n];
            if (strcmp(outputFormat, "csv") == 0) {
                pArgs->outFmt = csv;
            } else if (strcmp(outputFormat, "gpx") == 0) {
                pArgs->outFmt = gpx;
            } else {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, outputFormat);
                return -1;
            }
        } else if (strcmp(arg, "--rel-time") == 0) {
            pArgs->relTime = true;
        } else if (strcmp(arg, "--set-speed") == 0) {
            const char *setSpeed = argv[++n];
            if (sscanf(setSpeed, "%le", &pArgs->setSpeed) != 1) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, setSpeed);
                return -1;
            }
            pArgs->setSpeed = (pArgs->setSpeed / 3.6);  // convert from km/h to m/s
        } else if (strcmp(arg, "--sma-window") == 0) {
            const char *smaWindow = argv[++n];
            if ((sscanf(smaWindow, "%d", &pArgs->smaWindow) != 1) ||
                ((pArgs->smaWindow % 2) == 0)) {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, smaWindow);
                return -1;
            }
        } else if (strcmp(arg, "--start-time") == 0) {
            const char *startTime = argv[++n];
            struct tm brkDwnTime = {0};
            time_t time0;
            if (strcmp(startTime, "now") == 0) {
                time0 = time(NULL);
            } else if (strptime(startTime, "%Y-%m-%dT%H:%M:%S", &brkDwnTime) != NULL) {
                time0 = mktime(&brkDwnTime);
            } else {
                fprintf(stderr, "Invalid argument: %s %s\n", arg, startTime);
                return -1;
            }
            pArgs->startTime = (double) time0;
        } else if (strcmp(arg, "--summary") == 0) {
            pArgs->summary = true;
            pArgs->relTime = true;  // force relative timestamps
        } else if (strcmp(arg, "--trim") == 0) {
            pArgs->trim = true;
        } else if (strcmp(arg, "--version") == 0) {
            fprintf(stdout, "Version %s %s\n", PROGRAM_VERSION, buildInfo);
            exit(0);
        } else {
            fprintf(stderr, "Invalid option: %s\n", arg);
            return -1;
        }
    }

    pArgs->argc = argc;
    pArgs->argv = argv;

    if (pArgs->inFile == NULL) {
        // By default read input from stdin
        pArgs->inFile = stdin;
    }

    if (pArgs->outFile == NULL) {
        // By default send output to stdout
        pArgs->outFile = stdout;
    }

    if (pArgs->outFmt == nil) {
        // By default use GPX output format
        pArgs->outFmt = gpx;
    }

    if (pArgs->type == 0) {
        // By default use a Ride activity type
        pArgs->type = 1;
    }

    return 0;
}

// Parse the GPX file and create a list of Track Points
static GpsTrk *parseFile(CmdArgs *pArgs)
{
    GpsTrk *pTrk;
    TrkPt *pTrkPt = NULL;
    TrkPt *prevTrkPt = NULL;
    int index = 0;
    int trkPtNum = 0;
    int lineNum = 0;
    int metaData = 0;
    int trimTrkPts = false;
    double trimmedTime = 0.0;
    static char lineBuf[4096];

    // Check the input file type
    if ((fgets(lineBuf, sizeof(lineBuf), pArgs->inFile) == NULL) ||
        (strstr(lineBuf, "<?xml ") == NULL)) {
        fprintf(stderr, "Input file is not a valid GPX file !!!\n");
        return NULL;
    }
    lineNum += 1;

    // Create the GpsTrk object
    if ((pTrk = calloc(1, sizeof(GpsTrk))) == NULL) {
        fprintf(stderr, "Failed to alloc GpsTrk !!!\n");
        return NULL;
    }
    TAILQ_INIT(&pTrk->trkPtList);

    // Process one line at a time, looking for a <trkpt> ... </trkpt>
    // block that defines a track point.
    while (fgets(lineBuf, sizeof(lineBuf), pArgs->inFile) != NULL) {
        double latitude, longitude, elevation;
        struct tm brkDwnTime = {0};
        int ambTemp, cadence, heartRate, power;
        const char *p;

        lineNum++;

        //fprintf(stdout, "%u: %s", lineNum, lineBuf);

        // Ignore the metadata
        if (strstr(lineBuf, "<metadata>") != NULL) {
            metaData++;
            continue;
        } else if (strstr(lineBuf, "</metadata>") != NULL) {
            metaData--;
            continue;
        } else if (metaData) {
            continue;
        }

        if ((sscanf(lineBuf, " <trkpt lat=\"%le\" lon=\"%le\">", &latitude, &longitude) == 2) ||
            (sscanf(lineBuf, " <trkpt lon=\"%le\" lat=\"%le\">", &longitude, &latitude) == 2)) {
            // New Track Point!
            if (pTrkPt != NULL) {
                // Hu?
                fprintf(stderr, "SPONG! Nested <trkpt> block !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Update absolute TrkPt index. This index increases
            // monotonically, even for TrkPts that are trimmed out.
            index++;

            if ((pTrkPt = calloc(1, sizeof(TrkPt))) == NULL) {
                fprintf(stderr, "Failed to alloc TrkPt !!!\n");
                return NULL;
            }

            pTrkPt->lineNum = lineNum;
            pTrkPt->latitude = latitude;
            pTrkPt->longitude = longitude;
        } else if (sscanf(lineBuf, " <ele>%le</ele>", &elevation) == 1) {
            // Got the elevation!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->elevation = elevation;
        } else if ((p = strptime(lineBuf, " <time>%Y-%m-%dT%H:%M:%S", &brkDwnTime)) != NULL) {
            time_t timeStamp;
            int ms = 0;

            // Got the time!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Convert to seconds since the Epoch
            timeStamp = mktime(&brkDwnTime);

            // If present, read the millisec portion
            if (sscanf(p, ".%d", &ms) == 1) {
                if ((ms < 0) || (ms > 999)) {
                    fprintf(stderr, "Invalid millisec value: %d\n", ms);
                    return NULL;
                }
            }

            pTrkPt->time = (double) timeStamp + ((double) ms / 1000.0);  // seconds+millisec since the Epoch
        } else if (sscanf(lineBuf, " <power>%d</power>", &power) == 1) {
            // Got the power!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->power = power;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:atemp>%d</gpxtpx:atemp>", &ambTemp) == 1) {
            // Got the ambient temperature!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->ambTemp = ambTemp;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:cad>%d</gpxtpx:cad>", &cadence) == 1) {
            // Got the cadence!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->cadence = cadence;
            pTrk->optTagCount++;
        } else if (sscanf(lineBuf, " <gpxtpx:hr>%d</gpxtpx:hr>", &heartRate) == 1) {
            // Got the heart rate!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }
            pTrkPt->heartRate = heartRate;
            pTrk->optTagCount++;
        } else if (strstr(lineBuf, "</trkpt>") != NULL) {
            // End of Track Point!
            if (pTrkPt == NULL) {
                // Hu?
                fprintf(stderr, "SPONG! No active <trkpt> block !!! #%u \"%s\"\n", lineNum, lineBuf);
                return NULL;
            }

            // Let's do some consistency checks...

            // Without elevation data, there isn't much we can do!
            if (pTrkPt->elevation == 0.0) {
                fprintf(stderr, "TrkPt at line #%u is missing its elevation data!\n", pTrkPt->lineNum);
                return NULL;
            }

            if (pArgs->startTime == 0.0) {
                if (pTrkPt->time == 0.0) {
                    fprintf(stderr, "TrkPt at line #%u is missing its time data!\n", pTrkPt->lineNum);
                    return NULL;
                }
                if ((prevTrkPt != NULL) && (pTrkPt->time <= prevTrkPt->time)) {
                        fprintf(stderr, "TrkPt at line #%u has a non-increasing timestamp from the previous point at line #%u!\n",
                                pTrkPt->lineNum, prevTrkPt->lineNum);
                        return NULL;
                }
            }

            {
                Bool discTrkPt = false;

                // Some GPX tracks may have duplicate TrkPt's
                if ((prevTrkPt != NULL) &&
                    (prevTrkPt->latitude == pTrkPt->latitude) &&
                    (prevTrkPt->longitude == pTrkPt->longitude) &&
                    (prevTrkPt->elevation == pTrkPt->elevation) &&
                    (prevTrkPt->time == pTrkPt->time)) {
                    if (!pArgs->quiet) {
                        fprintf(stderr, "WARNING: TrkPt at line #%u is a duplicate of TrkPt at line #%u! (latitude=%.10lf longitude=%.10lf elevation=%.10lf time=%.3lf\n",
                                pTrkPt->lineNum, prevTrkPt->lineNum, pTrkPt->latitude, pTrkPt->longitude, pTrkPt->elevation, pTrkPt->time);
                    }
                    pTrk->numDupTrkPts++;
                    discTrkPt = true;
                }

                // Do we need to trim this TrkPt?
                if (pArgs->trim) {
                    if (index == pArgs->rangeFrom) {
                        trimTrkPts = true; // start trimming
                        trimmedTime = pTrkPt->time;  // set baseline time
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    } else if (index == pArgs->rangeTo) {
                        trimTrkPts = false; // stop trimming
                        trimmedTime = pTrkPt->time - trimmedTime + 1;    // total time trimmed
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    } else if (trimTrkPts) {
                        pTrk->numTrimTrkPts++;
                        discTrkPt = true;
                    }
                }

                // Discard?
                if (discTrkPt) {
                    free(pTrkPt);
                    pTrkPt = NULL;
                    continue;
                }
            }

            // This TrkPt has been "accepted" !

            pTrkPt->index = ++trkPtNum;

            if (trimmedTime) {
                // If we trimmed out some points, move the timestamp
                // back in time to avoid a discontinuity in the time
                // sequence.
                pTrkPt->time -= trimmedTime;
            }

            // Insert track point at the tail of the queue and update
            // the TrkPt count.
            TAILQ_INSERT_TAIL(&pTrk->trkPtList, pTrkPt, tqEntry);
            pTrk->numTrkPts++;

            prevTrkPt = pTrkPt;
            pTrkPt = NULL;
        } else {
            // Ignore this line...
        }
    }

    // Done reading all the TrkPt's!

    // The first point is used a the reference...
    if ((pTrkPt = TAILQ_FIRST(&pTrk->trkPtList)) != NULL) {
        if (pTrkPt->time == 0.0) {
            // TrkPt has no time information, likely because this
            // is a GPX route, not a ride. In this case we need to
            // have a startTime and a setSpeed defined, in order
            // to be able to generate the timestamps...
            if ((pArgs->startTime == 0) || (pArgs->setSpeed == 0.0)) {
                fprintf(stderr, "TrkPt is missing time information and no startTime or setSpeed has been specified!\n");
                return NULL;
            }

            pTrkPt->time = pArgs->startTime;
        } else if (pArgs->startTime != 0) {
            // Set the time offset used to change the start time
            // of the activity.
            pTrk->timeOffset = pArgs->startTime - pTrkPt->time;
        }

        // If necessary, set the base time reference used to
        // generate relative timestamps in the CSV output data.
        if (pArgs->relTime) {
            pTrk->baseTime = pTrkPt->time;
        }
    } else {
        fprintf(stdout, "No track points found!\n");
    }

    return pTrk;
}

// Compute the distance (in meters) between two track points
// using the Haversine formula. See:
//
//   https://en.wikipedia.org/wiki/Haversine_formula
//
// for the details.
static double compDistance(const TrkPt *p1, const TrkPt *p2)
{
    double latitude1 = p1->latitude * degToRad; // p1's latitude in radians
    double latitude2 = p2->latitude * degToRad; // p2's latitude in radians
    double latDiff = (p2->latitude - p1->latitude) * degToRad; // latitude diff in radians
    double lonDiff = (p2->longitude - p1->longitude) * degToRad; // longitude diff in radians
    double a;
    double c;

    a = pow(sin(latDiff/2), 2) + cos(latitude1) * cos(latitude2) * pow(sin(lonDiff/2), 2);
    assert(a <= 1.0);
    c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));

    return (c * earthMeanRadius);
}

// Given a fixed distance (deltaP) figure out what the
// elevation difference (deltaE) should be, in order to
// get the desired grade value, and adjust the elevation
// value accordingly.
static void adjElevation(GpsTrk *pTrk, TrkPt *p1, TrkPt *p2)
{
    double grade = (p2->grade / 100.0); // desired grade in decimal (0.00 .. 1.00)
    double grade2 = (grade * grade);    // grade squared
    double deltaP2 = (p2->deltaP * p2->deltaP); // deltaP squared
    double rise = sqrt((grade2 * deltaP2) / (1.0 + grade2));
    double adjElev;

    if (p2->deltaE >= 0.0) {
        p2->deltaE = rise;
    } else {
        p2->deltaE = (0.0 - rise);
    }
    adjElev = p1->elevation + p2->deltaE;
    if (adjElev != p2->elevation) {
        p2->elevation = adjElev;
        pTrk->numElevAdj++;
    }
}

static int compDataPhase1(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = NULL;   // previous TrkPt
    TrkPt *p2 = NULL;   // current TrkPt

    // Compute the distance, elevation diff, speed, and grade
    // between each pair of points...
    TAILQ_FOREACH(p2, &pTrk->trkPtList, tqEntry) {
        Bool stopped = false;

        if (p1 != NULL) {
            // Compute the position difference (distance) between
            // the two points.
            p2->deltaP = compDistance(p1, p2);

            if (p2->time == 0.0) {
                // TrkPt has no timestamp, so compute the time
                // interval deltaP based on the distance deltaP
                // (in m) and the specified speed (in m/s).
                double deltaT = (p2->deltaP / pArgs->setSpeed); // always positive
                if (deltaT == 0.0) {
                    deltaT = 0.1;
                }
                p2->time = p1->time + deltaT;
            }

            // Compute the time interval between the two points.
            // Ideally fixed at 1-sec, but some GPS devices (e.g.
            // Garmin Edge) may use a "smart" recording mode that
            // can have several seconds between points...
            p2->deltaT = (p2->time - p1->time);

            // Paranoia?
            if (p2->deltaT <= 0) {
                fprintf(stderr, "SPONG! TrkPt at line #%u has a non-increasing timestamp !\n",
                        p2->lineNum);
            }

            // Compute the speed as "distance over time", and
            // convert it from m/s to km/h.
            p2->speed = ((p2->deltaP * 3.6) / p2->deltaT);

            // Are we stopped?
            if (p2->speed == 0.0) {
                stopped = true;
            } else if ((pArgs->minSpeed != 0.0) && (p2->speed < pArgs->minSpeed)) {
                // The speed is below the specified minimum value
                // so assume we are stopped.
                if (!pArgs->quiet) {
                    fprintf(stderr, "WARNING: TrkPt at line #%u has a speed value %.10lf km/h below the minimum value %.10lf km/h !\n",
                            p2->lineNum, p2->speed, pArgs->minSpeed);
                }

                stopped = true;
            } else {
                stopped = false;
            }

            if (stopped) {
                if (!pArgs->quiet) {
                    fprintf(stderr, "WARNING: Stopped! (line #%u, speed %.10lf km/h, deltaT %.3lf, stoppedTime %ld\n",
                            p2->lineNum, p2->speed, p2->deltaT, (time_t) pTrk->stoppedTime);
                }

                // Update the stopped time value for the activity
                pTrk->stoppedTime += p2->deltaT;

                // Set the speed to zero, to indicate we were not
                // moving, and skip this point when we generate
                // the output data.
                p2->speed = 0.0;
            } else {
                // Adjust the timestamp to account for any earlier
                // stopped time.
                p2->adjTime = p2->time - pTrk->stoppedTime;

                // Update the total distance for the activity
                pTrk->distance += p2->deltaP;

                // Set the distance (from the start) of this
                // point.
                p2->distance = pTrk->distance;

                // Update the total time for the activity
                pTrk->time += p2->deltaT;

                // Update the max time interval between two points
                if (p2->deltaT > pTrk->maxDeltaT) {
                    pTrk->maxDeltaT = p2->deltaT;
                    pTrk->maxTimeIntTrkPt = p2;
                }

                // Now let's compute the grade!
                {
                    double distance = p2->deltaP;
                    double rise;

                    // Elevation difference (can be negative)
                    p2->deltaE = p2->elevation - p1->elevation;

                    // The rise is always positive!
                    rise = fabs(p2->deltaE);

                    // Use Pythagoras's Theorem to compute the horizontal
                    // distance (run) based on the distance (hypotenuse)
                    // and the elevation difference (rise). Notice that
                    // the rise value inherits whatever error the elevation
                    // value may have. Notice also that the drawing of the
                    // triangle below is not realistic, as even with a
                    // steep 25% grade, a run of 1 meter would have a rise
                    // of only 0.25 meter, so the triangle would typically
                    // have a longer run than rise, being "long and short"
                    // when drawn to scale.
                    //
                    //                 p2 +
                    //                   /|
                    //                  / |
                    //                 /  |
                    //       distance /   | rise
                    //               /    |
                    //              /     |
                    //             /      |
                    //         p1 +-------+
                    //               run
                    //
                    //    run^2 + rise^2 = distance^2
                    //
                    // Under normal circumstances, the distance is always
                    // larger than the rise.  But when the GPS elevation
                    // data is bad, the rise value may be larger than the
                    // distance, in which case Pythagoras's Theorem would
                    // not work anymore. In those cases we "fix" the rise
                    // value so that it is consistent with the max grade
                    // allowed.
                    if (distance < rise) {
                        if (!pArgs->quiet) {
                            fprintf(stderr, "WARNING: TrkPt at line #%u has inconsistent distance (%.10lf) and rise (%.10lf) values! (speed=%.3lf km/h)\n",
                                    p2->lineNum, distance, rise, p2->speed);
                        }
                        p2->grade = (pArgs->maxGrade != 0.0) ? pArgs->maxGrade : 25.0;  // cap the grade at maxGrade or at 25%
                        adjElevation(pTrk, p1, p2);
                        rise = fabs(p2->deltaE);
                    }

                    {
                        double runSquare = (distance * distance) - (rise * rise);

                        if (runSquare > 0.0) {
                            p2->run = sqrt(runSquare);
                        } else {
                            // Hu? This should not happen!
                            fprintf(stderr, "SPONG! TrkPt at line #%u has a negative runSquare value ! (distance=%.10lf rise=%.10lf runSquare=%.10lf)\n",
                                    p2->lineNum, distance, rise, runSquare);
                            return -1;
                        }

                        if (p2->run != 0.0) {
                            // Compute the grade as "rise over run". Here we use deltaE
                            // instead of rise, so that the grade value has the right
                            // sign...
                            p2->grade = (p2->deltaE * 100.0) / p2->run;  // in [%]
                        } else {
                            // Hu? This should not happen!
                            if (!pArgs->quiet) {
                                fprintf(stderr, "WARNING: TrkPt at line #%u has a null run value !\n",
                                        p2->lineNum);
                            }

                            // Use the values from the previous point
                            p2->elevation = p1->elevation;
                            p2->speed = p1->speed;
                            p2->grade = p1->grade;
                        }
                    }
                }
            }
        }

        p1 = p2;
    }

    return 0;
}

// Compute the Simple Moving Average (SMA) of the grade value
// of the given point. The SMA uses a window size of N points,
// where N is an odd value. The average is computed using the
// (N-1)/2 values before the point, the value of the point,
// and the (N-1)/2 values after the point. Notice that for the
// first few points and for the last few points in the track,
// the SMA is computed over fewer than N points.
//
//   <-- (N-1)/2 --> <-- (N-1)/2 -->
//   +--------------+---------------+
//                  p
//
static void compGradeSma(GpsTrk *pTrk, TrkPt *p, int smaWindow)
{
    int i;
    int n = (smaWindow - 1) / 2;
    int numPoints = 1;
    double gradeSum = p->grade;
    TrkPt *tp;

    // Points before the given point
    for (i = 0, tp = TAILQ_PREV(p, TrkPtList, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_PREV(tp, TrkPtList, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Points after the given point
    for (i = 0, tp = TAILQ_NEXT(p, tqEntry); (i < n) && (tp != NULL); i++, tp = TAILQ_NEXT(tp, tqEntry)) {
        gradeSum += tp->grade;
        numPoints++;
    }

    // Override the original grade value with the
    // computed SMA value.
    p->grade = gradeSum / numPoints;

    // Flag that this point had its grade adjusted
    p->adjGrade = true;
}

static int pointWithinRange(const CmdArgs *pArgs, const TrkPt *p)
{
    if (pArgs->rangeFrom == 0) {
        // No actual range specified, so all points
        // are within range...
        return true;
    }

    if ((p->index >= pArgs->rangeFrom) && (p->index <= pArgs->rangeTo)) {
        // Point is within specified range
        return true;
    }

    return false;
}

static void adjMaxGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt at line #%u has a grade of %.2lf%% that exceeds the max value %.2lf%% !\n",
                p2->lineNum, p2->grade, pArgs->maxGrade);
    }

    // Override original value with the max value
    p2->grade = pArgs->maxGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static void adjMinGrade(GpsTrk *pTrk, CmdArgs *pArgs, TrkPt *p1, TrkPt *p2)
{
    if (!pArgs->quiet) {
        fprintf(stderr, "WARNING: TrkPt at line #%u has a grade of %.2lf%% that exceeds the min value %.2lf%% !\n",
                p2->lineNum, p2->grade, pArgs->minGrade);

    }

    // Override original value with the min value
    p2->grade = pArgs->minGrade;

    // Flag that this point had its grade adjusted
    p2->adjGrade = true;
}

static int compDataPhase2(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p1 = NULL;   // previous TrkPt
    TrkPt *p2 = NULL;   // current TrkPt

    TAILQ_FOREACH(p2, &pTrk->trkPtList, tqEntry) {
        if (p1 != NULL) {
            // Skip points where we were stopped
            if (p2->speed != 0.0) {
                if (pArgs->smaWindow != 0) {
                    // Compute the SMA of the grade value
                    compGradeSma(pTrk, p2, pArgs->smaWindow);
                }

                // See if we need to limit the max grade values
                if ((pArgs->maxGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade > pArgs->maxGrade)) {
                    adjMaxGrade(pTrk, pArgs, p1, p2);
                }

                // See if we need to limit the min grade values
                if ((pArgs->minGrade != 0.0) &&
                    pointWithinRange(pArgs, p2) &&
                    (p2->grade < pArgs->minGrade)) {
                    adjMinGrade(pTrk, pArgs, p1, p2);
                }

                // If necessary, correct the elevation value based
                // on the adjusted grade value. We need to adjust
                // the value of delatE, while the value of deltaP
                // remains invariant; i.e. the deltaP vector needs
                // to rotate along an arc so that its angle results
                // in the adjusted grade value.
                //
                // deltaE^2 = (grade^2 x deltaP^2) / (1 + grade^2)
                //
                if (p2->adjGrade) {
                    adjElevation(pTrk, p1, p2);
                }

                // Update the rolling elevation gain/loss values
                if (p2->deltaE >= 0) {
                    pTrk->elevGain += p2->deltaE;
                } else {
                    pTrk->elevLoss -= p2->deltaE;
                }

                // Update the min/max values
                if (p2->speed > pTrk->maxSpeed) {
                     pTrk->maxSpeed = p2->speed;
                     pTrk->maxSpeedTrkPt = p2;
                }
                if (p2->grade > pTrk->maxGrade) {
                     pTrk->maxGrade = p2->grade;
                     pTrk->maxGradeTrkPt = p2;
                } else if (p2->grade < pTrk->minGrade) {
                    pTrk->minGrade = p2->grade;
                    pTrk->minGradeTrkPt = p2;
                }
            }
        }

        p1 = p2;
    }

    return 0;
}

static void printSummary(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t time;
    time_t hr, min, sec;
    const TrkPt *p;

    fprintf(pArgs->outFile, "    numTrkPts: %d\n", pTrk->numTrkPts);
    fprintf(pArgs->outFile, " numDupTrkPts: %d\n", pTrk->numDupTrkPts);
    fprintf(pArgs->outFile, "numTrimTrkPts: %d\n", pTrk->numTrimTrkPts);
    fprintf(pArgs->outFile, "   numElevAdj: %d\n", pTrk->numElevAdj);

    // Total time
    time = pTrk->time;
    hr = time / 3600;
    min = (time - (hr * 3600)) / 60;
    sec = (time - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, "         time: %02ld:%02ld:%02ld\n", hr, min, sec);

    // Moving time
    time = pTrk->time - pTrk->stoppedTime;
    hr = time / 3600;
    min = (time - (hr * 3600)) / 60;
    sec = (time - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, "   movingTime: %02ld:%02ld:%02ld\n", hr, min, sec);

    // Stopped time
    time = pTrk->stoppedTime;
    hr = time / 3600;
    min = (time - (hr * 3600)) / 60;
    sec = (time - (hr * 3600)) % 60;
    fprintf(pArgs->outFile, "  stoppedTime: %02ld:%02ld:%02ld\n", hr, min, sec);

    fprintf(pArgs->outFile, "     distance: %.10lf km\n", (pTrk->distance / 1000.0));
    fprintf(pArgs->outFile, "     elevGain: %.10lf m\n", pTrk->elevGain);
    fprintf(pArgs->outFile, "     elevLoss: %.10lf m\n", pTrk->elevLoss);
    if ((p = pTrk->maxTimeIntTrkPt) != NULL) {
        fprintf(pArgs->outFile, "    maxDeltaT: %.3lf sec at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxDeltaT, p->index, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxSpeedTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     maxSpeed: %.10lf km/h at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxSpeed, p->index, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->maxGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     maxGrade: %.2lf%% at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->maxGrade, p->index, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
    if ((p = pTrk->minGradeTrkPt) != NULL) {
        fprintf(pArgs->outFile, "     minGrade: %.2lf%% at TrkPt #%d (line #%d) : time = %ld s, dist = %.2lf km\n",
                pTrk->minGrade, p->index, p->lineNum, (time_t) (p->time - pTrk->baseTime), (p->distance / 1000.0));
    }
}

static void printCsvFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    TrkPt *p;

    // Print column banner line
    fprintf(pArgs->outFile, "<line#>,<trkpt>,<time>,<lat>,<lon>,<ele>,");
    fprintf(pArgs->outFile, "<power>,<atemp>,<cadence>,<hr>,<deltaP>,<deltaT>,<deltaE>,run,<distance>,<speed>,<grade>\n");


    TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
        // Skip points where we were stopped
        if (p->speed != 0.0) {
            fprintf(pArgs->outFile, "%d,%d,%.3lf,%.10lf,%.10lf,%.10lf,",
                    p->lineNum,                     // <line#>
                    p->index,                       // <trkPt>
                    (p->time - pTrk->baseTime),     // <time>
                    p->latitude,                    // <lat>
                    p->longitude,                   // <lon>
                    p->elevation);                  // <ele>
            fprintf(pArgs->outFile, "%d,%d,%d,%d,%.10lf,%.3lf,%.10lf,%.10lf,%.10lf,%.10lf,%.2lf\n",
                    p->power,                       // <power>
                    p->ambTemp,                     // <atemp>
                    p->cadence,                     // <cadence>
                    p->heartRate,                   // <hr>
                    p->deltaP,                      // <deltaP>
                    p->deltaT,                      // <deltaT>
                    p->deltaE,                      // <deltaE>
                    p->run,                         // <run>
                    (p->distance / 1000.0),         // <distance>
                    p->speed,                       // <speed>
                    p->grade);                      // <grade>
        }
    }
}

static void printGpxFmt(GpsTrk *pTrk, CmdArgs *pArgs)
{
    time_t now;
    struct tm brkDwnTime = {0};
    char timeBuf[128];

    // Print headers
    fprintf(pArgs->outFile, "%s\n", xmlHeader);
    fprintf(pArgs->outFile, "%s\n", gpxHeader);

    // Print metadata
    now = time(NULL);
    strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&now, &brkDwnTime));
    fprintf(pArgs->outFile, "  <metadata>\n");
    fprintf(pArgs->outFile, "    <name> ...  </name>\n");
    fprintf(pArgs->outFile, "    <desc> numTrkPts=%d numDupTrkPts=%d numTrimTrkPts=%d numElevAdj=%d </desc>\n",
            pTrk->numTrkPts, pTrk->numDupTrkPts, pTrk->numTrimTrkPts, pTrk->numElevAdj);
    fprintf(pArgs->outFile, "    <author>gpxFileTool version %s [https://github.com/elfrances/gpxFileTool.git]</author>\n", PROGRAM_VERSION);
    fprintf(pArgs->outFile, "    <time>%s</time>\n", timeBuf);
    fprintf(pArgs->outFile, "  </metadata>\n");

    // Print track
    fprintf(pArgs->outFile, "  <trk>\n");
    if (pArgs->name != NULL) {
        fprintf(pArgs->outFile, "    <name>%s</name>\n", pArgs->name);
    }
    fprintf(pArgs->outFile, "    <type>%d</type>\n", pArgs->type);

    // Print track segment
    fprintf(pArgs->outFile, "    <trkseg>\n");
    {
        TrkPt *p;

        // Print all the track points
        TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
            // Skip points where we were stopped
            if (p->speed != 0.0) {
                double timeStamp = (p->adjTime != 0) ? p->adjTime : p->time;    // use the adjusted timestamp if there is one
                time_t time;
                int ms = 0;

                timeStamp += pTrk->timeOffset;
                time = (time_t) timeStamp;  // seconds only
                ms = (timeStamp - (double) time) * 1000.0;
                strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&time, &brkDwnTime));
                fprintf(pArgs->outFile, "      <trkpt lat=\"%.10lf\" lon=\"%.10lf\">\n", p->latitude, p->longitude);
                fprintf(pArgs->outFile, "        <ele>%.10lf</ele>\n", p->elevation);
                fprintf(pArgs->outFile, "        <time>%s.%03dZ</time>\n", timeBuf, ms);

                // Now the optional metrics, if any...
                if ((pTrk->optTagCount != 0) && (pArgs->outMask != OM_NONE)) {
                    fprintf(pArgs->outFile, "        <extensions>\n");
                    if (pArgs->outMask & OM_POWER) {
                        fprintf(pArgs->outFile, "          <power>%d</power>\n", p->power);
                    }
                    if (pArgs->outMask & (OM_ATEMP | OM_CADENCE | OM_HR)) {
                        fprintf(pArgs->outFile, "          <gpxtpx:TrackPointExtension>\n");
                        if (pArgs->outMask & OM_ATEMP) {
                            fprintf(pArgs->outFile, "            <gpxtpx:atemp>%d</gpxtpx:atemp>\n", p->ambTemp);
                        }
                        if (pArgs->outMask & OM_CADENCE) {
                            fprintf(pArgs->outFile, "            <gpxtpx:cad>%d</gpxtpx:cad>\n", p->cadence);
                        }
                        if (pArgs->outMask & OM_HR) {
                            fprintf(pArgs->outFile, "            <gpxtpx:hr>%d</gpxtpx:hr>\n", p->heartRate);
                        }
                        fprintf(pArgs->outFile, "          </gpxtpx:TrackPointExtension>\n");
                    }
                    fprintf(pArgs->outFile, "        </extensions>\n");
                }

                fprintf(pArgs->outFile, "      </trkpt>\n");
            }
        }
    }
    fprintf(pArgs->outFile, "    </trkseg>\n");

    fprintf(pArgs->outFile, "  </trk>\n");

    fprintf(pArgs->outFile, "</gpx>\n");
}

static int printOutput(GpsTrk *pTrk, CmdArgs *pArgs)
{
    if (pArgs->summary) {
        printSummary(pTrk, pArgs);
    } else if (pArgs->outFmt == csv) {
        printCsvFmt(pTrk, pArgs);
    } else if (pArgs->outFmt == gpx) {
        printGpxFmt(pTrk, pArgs);
    }

    return 0;
}

static void cleanup(CmdArgs *pArgs, GpsTrk *pTrk)
{
    fclose(pArgs->inFile);
    if (pArgs->outFile != stdout)
        fclose(pArgs->outFile);

    if (pTrk != NULL) {
        TrkPt *p;
        while ((p = TAILQ_FIRST(&pTrk->trkPtList)) != NULL) {
            TAILQ_REMOVE(&pTrk->trkPtList, p, tqEntry);
            free(p);
        }

        free(pTrk);
    }
}

int main(int argc, char **argv)
{
    CmdArgs cmdArgs = {0};
    GpsTrk *pTrk;
    int s = 0;

    // Parse the command arguments
    if (parseArgs(argc, argv, &cmdArgs) != 0) {
        return -1;
    }

    // Parse the GPX input data
    if ((pTrk = parseFile(&cmdArgs)) != NULL) {
        // Compute the speed & grade data
        if (compDataPhase1(pTrk, &cmdArgs) == 0) {
            // Do necessary adjustments
            compDataPhase2(pTrk, &cmdArgs);
        }

        // Generate the output data
        printOutput(pTrk, &cmdArgs);
    } else {
        fprintf(stderr, "Failed to parse input file\n");
        s = -1;
    }

    cleanup(&cmdArgs, pTrk);

    return s;
}


